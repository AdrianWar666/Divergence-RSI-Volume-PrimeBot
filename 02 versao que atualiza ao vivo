//+------------------------------------------------------------------+
//| üî• FUN√á√ÉO EQUILIBRADA: Linhas Quase Paralelas + Piv√¥s Reais     |
//| SOLU√á√ÉO: Busca pequena (¬±5 barras) por piv√¥s REAIS do RSI       |
//| pr√≥ximos aos piv√¥s de pre√ßo - LINHAS PARALELAS CORRIGIDAS       |
//+------------------------------------------------------------------+
//|               Divergence RSI volume e for√ßa PrimeBot            |
//|  ULTRA RESPONSIVO + SEPARA√á√ÉO VISUAL + VOLUME ENHANCED          |
//|                     Copyright PrimeBot 2025                      |
//|                  https://www.primebotportfolio.com.br/           |
//|------------------------------------------------------------------|
//| v2.3.8 - TRA√áADO RIGOROSO + EA CORRIGIDO + ANTI-LOOP           |
//| üîß BASE: v2.3.7 funcional mantida 100% intacta                  |
//| üî• NOVO v2.3.8: Anti-loop + EA sincronizado + Backtest corrigido|
//| üî• CORRE√á√ÉO CRUCIAL: Linhas RSI agora s√£o paralelas √†s de pre√ßo |
//| üî• BUSCA MELHORADA: ¬±5 barras para encontrar piv√¥s RSI corretos |
//| üî• FALLBACK INTELIGENTE: Sempre usa piv√¥s mais pr√≥ximos         |
//| üî• CORRE√á√ÉO TRA√áADO: N√£o corta topos/fundos intermedi√°rios      |
//| üî• VALIDA√á√ÉO REAL: Confirma "mais alto/baixo" antes de tra√ßar   |
//| üî• PIV√îS RIGOROSOS: Conecta apenas topo‚Üîtopo, fundo‚Üîfundo      |
//| üî• LINHA LIMPA: Verifica se tra√ßado passa sem obstru√ß√µes        |
//| üîß SEPARA√á√ÉO VISUAL: RSI (30-100) + Volume (0-30)              |
//| üîß CONTROLE SEQU√äNCIA: Evita sinais ap√≥s fundos consecutivos    |
//| üîß INCLINA√á√ÉO M√çNIMA: Filtra linhas quase retas                 |
//| üîß CONTEXTO TEND√äNCIA: Diverg√™ncia no contexto correto          |
//| üîß VOLUME VISUAL: M√©todo comparativo melhorado                  |
//| üî• VOLUME ENHANCED: Candles direcionais + Fluxo institucional   |
//| üî• SMART CONFIRMATION: 1 de 3 crit√©rios de volume               |
//| üî• L√ìGICA CORRIGIDA: Volume FORTE para AMBAS dire√ß√µes          |
//| üî• TEXTOS MELHORADOS: Maior, mais vis√≠vel, confirma√ß√£o estrelas |
//| üî• TEXTOS DETALHADOS: % pequenos para an√°lise (‚úìVol:X%)        |
//| üî• BOLINHAS VOLUME: Marcam confirma√ß√µes Enhanced no volume     |
//| üî• % FOR√áADO: Sempre mostra % quando estrela √© confirmada      |
//| üîß TRA√áADO INTELIGENTE: Opcional, linhas mais limpas           |
//| üîß RSI QUALIDADE: Evita "esticadas", cortes e linhas retas     |
//| üîß TEMPO REAL: M√°xima responsividade sem repintar               |
//| ‚úÖ RESULTADO: Volume alto confirma for√ßa em qualquer dire√ß√£o    |
//| üîß CORRE√á√ÉO: Escala √† direita correta + divis√≥ria invis√≠vel     |
//| üîß LICEN√áA: Conta "0" = Universal at√© data de expira√ß√£o         |
//| üéØ REEQUIL√çBRIO: Par√¢metros ajustados para eliminar sinais falsos |
//| üìä AN√ÅLISE VISUAL: Sempre mostra diverg√™ncias e % volume enhanced |
//| üî• CORRE√á√ÉO PIV√îS: L√≥gica de detec√ß√£o de topos/fundos corrigida |
//| üî• BUSCA EFETIVA: ¬±5 barras para garantir piv√¥s RSI reais          |
//| üî• MAIS PR√ìXIMO: Pega o topo/fundo RSI mais pr√≥ximo ao pre√ßo       |
//| ‚úÖ M√ÅXIMAS‚ÜîTOPOS: HIGH pre√ßo conecta com TOPOS RSI reais           |
//| ‚úÖ M√çNIMAS‚ÜîFUNDOS: LOW pre√ßo conecta com FUNDOS RSI reais          |
//| üî• TRA√áADO LIMPO: N√£o corta piv√¥s intermedi√°rios (v2.3.7)          |
//| üî• VALIDA√á√ÉO REAL: Confirma mais alto/baixo (v2.3.7)              |
//| üî• EA + BACKTEST: Sistema anti-loop + buffers sincronizados (v2.3.8) |
//+------------------------------------------------------------------+
#property copyright "Copyright PrimeBot 2025"
#property link      "https://www.primebotportfolio.com.br/"
#property version   "2.38"
#property description "Divergence RSI PrimeBot v2.3.8 - EA + BACKTEST + LINHAS PARALELAS CORRIGIDAS"
#property indicator_separate_window
#property indicator_buffers 14
#property indicator_plots   14
#property indicator_minimum 0
#property indicator_maximum 100

//--- Plots ORIGINAIS (mantidos)
#property indicator_label1  "RSI"
#property indicator_type1   DRAW_LINE
#property indicator_color1  clrDodgerBlue
#property indicator_style1  STYLE_SOLID
#property indicator_width1  2
#property indicator_label2  "Buy Signal"
#property indicator_type2   DRAW_ARROW
#property indicator_color2  clrPaleGreen
#property indicator_style2  STYLE_SOLID
#property indicator_width2  2
#property indicator_label3  "Sell Signal"
#property indicator_type3   DRAW_ARROW
#property indicator_color3  clrLightSalmon
#property indicator_style3  STYLE_SOLID
#property indicator_width3  2
#property indicator_label4  "RSI Divergence Line"
#property indicator_type4   DRAW_NONE
#property indicator_color4  clrYellow
#property indicator_style4  STYLE_SOLID
#property indicator_width4  3
#property indicator_label5  "Volume"
#property indicator_type5   DRAW_HISTOGRAM
#property indicator_color5  clrGray
#property indicator_style5  STYLE_SOLID
#property indicator_width5  2
#property indicator_label6  "Volume Average"
#property indicator_type6   DRAW_LINE
#property indicator_color6  clrYellow
#property indicator_style6  STYLE_SOLID
#property indicator_width6  1
#property indicator_label7  "Volume Buy Confirm"
#property indicator_type7   DRAW_ARROW
#property indicator_color7  clrGold
#property indicator_style7  STYLE_SOLID
#property indicator_width7  6
#property indicator_label8  "Volume Sell Confirm"
#property indicator_type8   DRAW_ARROW
#property indicator_color8  clrMagenta
#property indicator_style8  STYLE_SOLID
#property indicator_width8  6
#property indicator_label9  "Divider Line"
#property indicator_type9   DRAW_LINE
#property indicator_color9  clrDimGray
#property indicator_style9  STYLE_DOT
#property indicator_width9  1
#property indicator_label10 "Buy Signal Confirmed"
#property indicator_type10  DRAW_NONE
#property indicator_label11 "Sell Signal Confirmed"
#property indicator_type11  DRAW_NONE
#property indicator_label12 "Raw RSI Data"
#property indicator_type12  DRAW_NONE
#property indicator_label13 "Buy Circle Backtest"
#property indicator_type13  DRAW_ARROW
#property indicator_color13 clrGold
#property indicator_width13 5
#property indicator_label14 "Sell Circle Backtest"
#property indicator_type14  DRAW_ARROW
#property indicator_color14 clrMagenta
#property indicator_width14 5

// ‚úÖ ESCALAS CORRIGIDAS ORIGINAIS - Mant√©m escala 0-100 mas separa visualmente
#define RSI_ZONE_MIN 30.0       // RSI regi√£o visual m√≠nima
#define RSI_ZONE_MAX 100.0      // RSI regi√£o visual m√°xima  
#define VOLUME_ZONE_MIN 0.0     // Volume regi√£o visual m√≠nima
#define VOLUME_ZONE_MAX 25.0    // Volume regi√£o visual m√°xima
#define DIVIDER_LINE 28.0       // Linha divis√≥ria entre Volume e RSI
#define SYMBOL_STAR 108

//+------------------------------------------------------------------+
//| Enum ORIGINAL para modos de diverg√™ncia                         |
//+------------------------------------------------------------------+
enum ENUM_DIVERGENCE_MODE
{
   MODE_SENSITIVE = 0,      // Sensitive - Muitos sinais (para backtest)
   MODE_BALANCED = 1,       // Balanced - Recomendado (padr√£o)
   MODE_CONSERVATIVE = 2    // Conservative - S√≥ diverg√™ncias √≥bvias
};

//+------------------------------------------------------------------+
//| Inputs REEQUILIBRADOS - Ordem mantida + Par√¢metros ajustados    |
//+------------------------------------------------------------------+
input int RSI_Period = 14;
input ENUM_APPLIED_PRICE RSI_Applied = PRICE_CLOSE;
input bool OnlyExtremeLevels = false;
input double OverboughtLevel = 70.0;
input double OversoldLevel = 30.0;
input int MinBarsBetweenSignals = 8;              // üîß MAIS RIGOROSO: 1‚Üí8 (mais espa√ßamento temporal)

input int Volume_Period = 14;                    // Per√≠odo para m√©dia de volume - OTIMIZADO
input double Volume_Divergence_Min = 1.5;        // ‚úÖ MANTIDO: 1.5%
input double Min_Volume_Factor = 0.5;

input ENUM_DIVERGENCE_MODE DivergenceMode = MODE_BALANCED;       // ‚úÖ PADR√ÉO CORRETO: Balanced (Recomendado)
input int    DivergenceLookback = 18;        // üîß REEQUILIBRADO: 25‚Üí18 (menos barras distantes)
input int    PivotStrength = 1;              // ‚úÖ M√çNIMO: M√°xima sensibilidade
input double MinRSIDifference = 1.2;         // üîß REEQUILIBRADO: 0.8‚Üí1.2 (mais rigoroso)
input double MinPriceDifference = 0.025;     // üîß REEQUILIBRADO: 0.015‚Üí0.025 (mais rigoroso)
input bool   ShowModeInfo = true;            // Mostrar info do modo

input group "=== üî• MELHORIAS DE VOLUME v2.2.6 ==="
input bool UseEnhancedVolumeAnalysis = true;         // üî• USAR an√°lise enhanced de volume
input bool DetectCandleVolume = true;                // Volume em candles espec√≠ficos
input bool DetectInstitutionalFlow = true;           // Fluxo institucional
input double CandleVolumeThreshold = 120.0;          // % m√≠nimo volume na dire√ß√£o (120% = relaxado)
input double InstitutionalVolumeMin = 110.0;         // Volume institucional m√≠nimo (110% = relaxado)

input group "=== üîß Tra√ßado Inteligente v2.2.6 ==="
input bool UseCleanerLines = false;              // üîß PADR√ÉO DESABILITADO: Manter comportamento original
input double CleanLineTolerancePercent = 8.0;    // üîß MUITO TOLERANTE: 8% para m√°xima compatibilidade
input int MaxLineObstructions = 2;               // üîß NOVO: M√°ximo de obstru√ß√µes permitidas

input group "=== üî• Valida√ß√µes v2.2.6 REEQUILIBRADAS ==="
input double MinPivotAmplitude = 0.3;        // ‚úÖ ORIGINAL: Como estava funcionando
input bool   RequireTrendContext = true;    // üîß ATIVADO: Validar contexto da tend√™ncia
input double MinQualityScore = 20.0;         // üîß MAIS RIGOROSO: 12.0‚Üí20.0 (menos sinais)
input int    MinDistanceBetweenPivots = 5;   // üîß MAIS RIGOROSO: 3‚Üí5 (mais espa√ßamento)
input bool   RequireCleanLine = true;       // ‚úÖ ATIVADO: Filtro de obstru√ß√µes

input group "=== üîß Anti Look-Ahead Settings ==="
input bool EnableAntiLookAhead = false;          // ‚úÖ DESATIVADO: Comportamento consistente sempre
input int PivotConfirmationBars = 0;             // ‚úÖ SEM DELAY: Resposta imediata

input group "=== Visual Settings ==="
input bool RequireVolumeConfirmation = false;    // ‚úÖ SEMPRE VERIFICA VOLUME NAS ESTRELAS (movido)
input bool ShowStarsOnChart = true;              // Mostrar estrelas no gr√°fico (movido)
input bool EnableSignalsForEA = true;            // Liga sinais para EA (movido)
input color DividerColor = clrNONE;  // ‚úÖ Sem cor = invis√≠vel
input bool ShowDivergenceLines = true;               // ‚úÖ HABILITADO: Linhas para an√°lise visual (melhoradas)
input bool ShowVolumeCircles = true;             // üî• NOVO: Mostrar bolinhas no volume quando Enhanced confirma

input group "=== Debug v2.2.6 LOGS CONSOLE REDUZIDOS ==="
input bool ShowDebugInfo = false;                    // üî• LOGS CONSOLE: Desabilitado para reduzir experts
input bool ShowVolumeDebugOnChart = true;            // üî• TEXTOS GR√ÅFICO: Habilitado para an√°lise
input bool ShowOnlyConfirmedStars = true;            // üî• AJUSTADO: S√≥ mostrar onde h√° estrelas
input bool ShowDetailedVolumeInfo = true;            // üî• TEXTOS DETALHADOS: Habilitado para an√°lise
input int MaxVolumeTextsOnChart = 25;                // üî• AJUSTADO: 25 textos para an√°lise sem poluir

input group "=== üîß RSI Qualidade v2.2.6 REEQUILIBRADO ==="
input bool EnableRSITravelCheck = true;              // üîß MANTIDO: Verificar se RSI "estica" demais
input double RSIMaxDeviation = 25.0;                 // ‚úÖ MANTIDO: 25.0
input bool EnableRSIObstructionCheck = true;         // üîß MANTIDO: Verificar obstru√ß√µes na linha RSI
input int RSIMaxObstructions = 2;                    // üîß REEQUILIBRADO: 3‚Üí2 (mais rigoroso)
input bool EnableRSISlopeCheck = true;               // üîß MANTIDO: Verificar inclina√ß√£o m√≠nima do RSI
input double RSIMinSlope = 1.0;                      // üîß REEQUILIBRADO: 0.7‚Üí1.0 (mais rigoroso)

input group "=== üî• PIV√îS FLEX√çVEIS v2.2.6 MANTIDOS ==="
input bool UseFlexiblePivots = true;                 // ‚úÖ MANTIDO: Permitir piv√¥s de pre√ßo e RSI em barras pr√≥ximas
input int PivotSearchRange = 2;                      // ‚úÖ MANTIDO: Buscar piv√¥s em ¬±2 barras

input group "=== üî• Valida√ß√µes Rigorosas v2.3.7 ==="
input bool EnableStrictDivergenceCheck = true;       // üî• NOVO: Validar diverg√™ncia real (mais alto/baixo)
input bool EnableCleanLineCheck = true;              // üî• NOVO: Verificar tra√ßado limpo (n√£o corta piv√¥s)
input double LineTolerancePercent = 5.0;             // üî• NOVO: Toler√¢ncia para linha limpa (%)
input bool RequireStrictPivots = true;               // üî• NOVO: Exigir piv√¥s do mesmo tipo (topo com topo)
input bool ShowDivergenceValidation = true;          // üî• NOVO: Mostrar logs de valida√ß√£o
input int MaxSearchRangeForRSI = 5;                  // üî• AMPLIADO: Busca de piv√¥s RSI (¬±barras)

//+------------------------------------------------------------------+
//| Structs e Buffers                                               |
//+------------------------------------------------------------------+
struct RSIPivots
{
   int rsi_pivot_past;
   int rsi_pivot_current;
   bool valid;
};

//+------------------------------------------------------------------+
//| Buffers e Vari√°veis ORIGINAIS                                   |
//+------------------------------------------------------------------+
double RSIBuffer[], BuyBuffer[], SellBuffer[], RSILineBuffer[], VolumeBuffer[];
double VolumeAvgBuffer[], VolumeBuyConfirmBuffer[], VolumeSellConfirmBuffer[], DividerBuffer[];
double BuySignalConfirmedBuffer[], SellSignalConfirmedBuffer[], RawRSIBuffer[];
double BuyStarBacktestBuffer[], SellStarBacktestBuffer[];
int starCounter = 0;
int lineCounter = 0;
int lastBuySignalBar = -1;
int lastSellSignalBar = -1;
int RSIHandle;
long g_max_volume = 1;

// Debug contadores ORIGINAIS
int divergencesDetected = 0;
int signalsConfirmed = 0;
int signalsFiltered = 0;
int qualityFiltered = 0;
int contextFiltered = 0;
int mixedTypeFiltered = 0;
int realDivFiltered = 0;
int cleanLineFiltered = 0;

// ‚úÖ CONTROLE DE SEQU√äNCIA ORIGINAL
int lastBullishPivotBar = -1;
int lastBearishPivotBar = -1;
int consecutiveBullishPivots = 0;
int consecutiveBearishPivots = 0;

// üî• NOVO v2.3.8: Controle anti-loop (baseado no RSI PrimeBot v2.33)
int lastProcessedBuyBar = -1;
int lastProcessedSellBar = -1;
int copyBufferFailures = 0;

// ‚úÖ LICEN√áA AJUSTADA: Conta "0" = Universal
string licenseAccount = "0"; // Edite aqui: "0" para qualquer conta, ou n√∫mero espec√≠fico
datetime licenseExpiration = D'2025.12.31 17:55:59'; // Edite aqui a data de expira√ß√£o

// üî• NOVO: Contador de melhorias de volume
int enhancedVolumeUsed = 0;
int volumeTextsCreated = 0; // ‚úÖ Controlar quantidade de textos no gr√°fico

// üî• NOVO: Controles de logs do console
static datetime lastLogTime = 0;
static int logCooldownSeconds = 10;        // üî• M√°ximo 1 log a cada 10 segundos
static int totalLogsToday = 0;
static int maxLogsPerDay = 10;             // üî• M√°ximo 10 logs por dia
static datetime lastLogDate = 0;

// üî• NOVO: Contadores de valida√ß√µes rigorosas
int strictValidationPassed = 0;
int strictValidationFailed = 0;
int cleanLineRejections = 0;
int divergenceRejections = 0;

//+------------------------------------------------------------------+
//| üî• NOVO v2.3.8: Controle anti-loop (inspirado no RSI PrimeBot) |
//+------------------------------------------------------------------+
bool IsBarAlreadyProcessed(int bar_index, bool is_buy)
{
   if(is_buy)
   {
      if(bar_index == lastProcessedBuyBar)
         return true; // J√Å PROCESSADO - BLOQUEIA
      else
      {
         lastProcessedBuyBar = bar_index; // MARCA COMO PROCESSADO
         return false; // LIBERA PROCESSAMENTO
      }
   }
   else
   {
      if(bar_index == lastProcessedSellBar)
         return true; // J√Å PROCESSADO - BLOQUEIA
      else
      {
         lastProcessedSellBar = bar_index; // MARCA COMO PROCESSADO
         return false; // LIBERA PROCESSAMENTO
      }
   }
}

//+------------------------------------------------------------------+
//| üî• NOVO v2.3.8: Valida√ß√£o dist√¢ncia otimizada                  |
//+------------------------------------------------------------------+
bool IsValidSignalDistance(int current_bar, int last_signal_bar, int rates_total, bool is_buy)
{
   if(last_signal_bar < 0) return true; // Primeiro sinal sempre ok
   if(last_signal_bar >= rates_total) return true; // Reset se inv√°lido
   
   int distance = current_bar - last_signal_bar;
   return (distance > MinBarsBetweenSignals); // Dist√¢ncia m√≠nima
}

//+------------------------------------------------------------------+
//| üî• NOVO v2.3.8: Fun√ß√£o unificada processamento de sinal        |
//+------------------------------------------------------------------+
void ProcessConfirmedSignal(int bar_index, bool is_buy, const datetime &time[], 
                           const double &high[], const double &low[], 
                           double volumeChangePercent)
{
   // PASSO 1: SEMPRE preencher buffers EA (cr√≠tico para funcionar)
   if(EnableSignalsForEA)
   {
      if(is_buy)
      {
         BuySignalConfirmedBuffer[bar_index] = 1.0;
         SellSignalConfirmedBuffer[bar_index] = 0.0; // Limpar oposto
      }
      else
      {
         SellSignalConfirmedBuffer[bar_index] = 1.0;
         BuySignalConfirmedBuffer[bar_index] = 0.0; // Limpar oposto
      }
   }
   
   // PASSO 2: Estrelas nos buffers visuais (SEMPRE)
   if(is_buy)
   {
      BuyStarBacktestBuffer[bar_index] = high[bar_index];
      SellStarBacktestBuffer[bar_index] = 0.0; // Limpar oposto
      lastBuySignalBar = bar_index; // Atualizar controle
   }
   else
   {
      SellStarBacktestBuffer[bar_index] = low[bar_index];
      BuyStarBacktestBuffer[bar_index] = 0.0; // Limpar oposto
      lastSellSignalBar = bar_index; // Atualizar controle
   }
   
   // PASSO 3: Volume confirma√ß√£o visual
   if(is_buy)
   {
      double confirmLevel = MathMin(VolumeAvgBuffer[bar_index] + 3, VOLUME_ZONE_MAX - 1);
      VolumeBuyConfirmBuffer[bar_index] = confirmLevel;
      VolumeSellConfirmBuffer[bar_index] = 0.0;
   }
   else
   {
      double confirmLevel = MathMin(VolumeAvgBuffer[bar_index] + 3, VOLUME_ZONE_MAX - 1);
      VolumeSellConfirmBuffer[bar_index] = confirmLevel;
      VolumeBuyConfirmBuffer[bar_index] = 0.0;
   }
   
   // PASSO 4: Estrelas no gr√°fico (se habilitado)
   if(ShowStarsOnChart)
   {
      if(is_buy)
         CreateStar(time[bar_index], low[bar_index] - SymbolInfoDouble(_Symbol, SYMBOL_POINT) * 15, true);
      else
         CreateStar(time[bar_index], high[bar_index] + SymbolInfoDouble(_Symbol, SYMBOL_POINT) * 15, false);
   }
   
   // PASSO 5: Contadores e estat√≠sticas
   signalsConfirmed++;
   
   // PASSO 6: Debug controlado
   if(ShowDebugInfo)
   {
      PrintControlledLog("SINAL " + (is_buy ? "COMPRA" : "VENDA") + " CONFIRMADO v2.3.8 na barra " + (string)bar_index + 
            " | Volume: " + DoubleToString(volumeChangePercent, 1) + "% | EA Buffer: " + 
            (EnableSignalsForEA ? "ATIVADO" : "DESATIVADO"));
   }
}

//+------------------------------------------------------------------+
//| üî• NOVA FUN√á√ÉO: Controle de Logs do Console                     |
//+------------------------------------------------------------------+
bool CanPrintLog()
{
   datetime currentTime = TimeCurrent();
   datetime currentDate = (datetime)(currentTime / 86400) * 86400; // In√≠cio do dia
   
   // Reset contador di√°rio
   if(currentDate != lastLogDate)
   {
      lastLogDate = currentDate;
      totalLogsToday = 0;
   }
   
   // Verificar limites
   if(totalLogsToday >= maxLogsPerDay) return false;
   if(currentTime - lastLogTime < logCooldownSeconds) return false;
   
   // Atualizar contadores
   lastLogTime = currentTime;
   totalLogsToday++;
   
   return true;
}

void PrintControlledLog(string message)
{
   if(ShowDebugInfo && CanPrintLog())
   {
      Print("üî• ", message);
   }
}

//+------------------------------------------------------------------+
//| üî• NOVA FUN√á√ÉO: Validar Contexto do Candle para Confirma√ß√£o     |
//+------------------------------------------------------------------+
bool IsValidCandleContext(const double &open[], const double &close[], 
                         const double &high[], const double &low[], 
                         int position, bool is_buy_signal)
{
   if(position < 3) return true; // N√£o h√° dados suficientes
   
   // Verificar tipo do candle atual
   bool current_candle_bullish = close[position] > open[position];
   bool current_candle_bearish = close[position] < open[position];
   
   // Verificar momentum dos √∫ltimos 3 candles
   int bullish_candles = 0;
   int bearish_candles = 0;
   
   for(int i = 0; i < 3; i++)
   {
      int bar = position - i;
      if(bar >= 0)
      {
         if(close[bar] > open[bar]) bullish_candles++;
         if(close[bar] < open[bar]) bearish_candles++;
      }
   }
   
   if(is_buy_signal)
   {
      // COMPRA: Preferir confirma√ß√£o quando h√° press√£o vendedora ou corre√ß√£o
      // ‚ùå N√ÉO confirmar compra em forte movimento de alta
      if(bullish_candles >= 3) // 3 candles verdes consecutivos = muito otimista para compra
      {
         if(ShowDivergenceValidation)
            PrintControlledLog("COMPRA REJEITADA - Contexto muito otimista (3 candles verdes)");
         return false;
      }
      
      // ‚úÖ Preferir contexto neutro ou ligeiramente baixista
      return true;
   }
   else
   {
      // VENDA: Preferir confirma√ß√£o quando h√° press√£o compradora ou corre√ß√£o
      // ‚ùå N√ÉO confirmar venda em forte movimento de baixa
      if(bearish_candles >= 3) // 3 candles vermelhos consecutivos = muito pessimista para venda
      {
         if(ShowDivergenceValidation)
            PrintControlledLog("VENDA REJEITADA - Contexto muito pessimista (3 candles vermelhos)");
         return false;
      }
      
      // ‚úÖ Preferir contexto neutro ou ligeiramente altista
      return true;
   }
}

//+------------------------------------------------------------------+
//| üî• NOVA FUN√á√ÉO: Validar Timing da Confirma√ß√£o                   |
//+------------------------------------------------------------------+
bool IsValidConfirmationTiming(const double &open[], const double &close[], 
                              const double &high[], const double &low[], 
                              int position, bool is_buy_signal)
{
   if(position < 1) return true;
   
   bool current_candle_bullish = close[position] > open[position];
   bool current_candle_bearish = close[position] < open[position];
   
   if(is_buy_signal)
   {
      // COMPRA: OK confirmar em candle vermelho (corre√ß√£o) ou doji
      // ‚ùå EVITAR confirmar em candle verde forte (j√° subiu muito)
      
      if(current_candle_bullish)
      {
         double candle_size = MathAbs(close[position] - open[position]);
         double candle_range = high[position] - low[position];
         double body_ratio = candle_range > 0 ? candle_size / candle_range : 0;
         
         // Se candle verde tem corpo > 70% do range = movimento forte
         if(body_ratio > 0.7)
         {
            if(ShowDivergenceValidation)
               PrintControlledLog("COMPRA REJEITADA - Candle verde muito forte (" + DoubleToString(body_ratio*100, 0) + "% corpo)");
            return false;
         }
      }
      
      return true; // OK confirmar em candle vermelho, doji ou verde pequeno
   }
   else
   {
      // VENDA: OK confirmar em candle verde (corre√ß√£o) ou doji  
      // ‚ùå EVITAR confirmar em candle vermelho forte (j√° caiu muito)
      
      if(current_candle_bearish)
      {
         double candle_size = MathAbs(close[position] - open[position]);
         double candle_range = high[position] - low[position];
         double body_ratio = candle_range > 0 ? candle_size / candle_range : 0;
         
         // Se candle vermelho tem corpo > 70% do range = movimento forte
         if(body_ratio > 0.7)
         {
            if(ShowDivergenceValidation)
               PrintControlledLog("VENDA REJEITADA - Candle vermelho muito forte (" + DoubleToString(body_ratio*100, 0) + "% corpo)");
            return false;
         }
      }
      
      return true; // OK confirmar em candle verde, doji ou vermelho pequeno
   }
}
bool IsValidDivergenceDirection(double price_past, double price_current, 
                               double rsi_past, double rsi_current, bool is_bullish)
{
   if(is_bullish)
   {
      // COMPRA: Pre√ßo faz fundo MAIS BAIXO + RSI faz fundo MAIS ALTO
      bool price_lower = (price_current < price_past);      // Fundo mais baixo
      bool rsi_higher = (rsi_current > rsi_past);           // RSI mais alto (diverg√™ncia)
      
      if(ShowDivergenceValidation && (!price_lower || !rsi_higher))
      {
         PrintControlledLog("COMPRA REJEITADA - Pre√ßo: " + (price_lower ? "‚úìMais baixo" : "‚úóN√£o mais baixo") + 
                           " | RSI: " + (rsi_higher ? "‚úìMais alto" : "‚úóN√£o mais alto"));
         divergenceRejections++;
      }
      
      return price_lower && rsi_higher;
   }
   else
   {
      // VENDA: Pre√ßo faz topo MAIS ALTO + RSI faz topo MAIS BAIXO  
      bool price_higher = (price_current > price_past);     // Topo mais alto
      bool rsi_lower = (rsi_current < rsi_past);            // RSI mais baixo (diverg√™ncia)
      
      if(ShowDivergenceValidation && (!price_higher || !rsi_lower))
      {
         PrintControlledLog("VENDA REJEITADA - Pre√ßo: " + (price_higher ? "‚úìMais alto" : "‚úóN√£o mais alto") + 
                           " | RSI: " + (rsi_lower ? "‚úìMais baixo" : "‚úóN√£o mais baixo"));
         divergenceRejections++;
      }
      
      return price_higher && rsi_lower;
   }
}

//+------------------------------------------------------------------+
//| üî• NOVA FUN√á√ÉO: Verificar se Linha Corta Piv√¥s Intermedi√°rios   |
//+------------------------------------------------------------------+
bool LinePassesCleanly(const double &data[], int start_bar, int end_bar, 
                      bool is_bullish, double tolerance_percent = 5.0)
{
   if(!EnableCleanLineCheck) return true; // Se desabilitado, sempre aprova
   if(start_bar >= end_bar) return false;
   
   double start_value = data[start_bar];
   double end_value = data[end_bar];
   double line_tolerance = MathAbs(end_value - start_value) * (tolerance_percent / 100.0);
   
   // Verificar se h√° piv√¥s intermedi√°rios que cortam a linha
   for(int i = start_bar + 1; i < end_bar; i++)
   {
      // Calcular onde a linha deveria estar neste ponto
      double line_ratio = (double)(i - start_bar) / (double)(end_bar - start_bar);
      double expected_line_value = start_value + (end_value - start_value) * line_ratio;
      
      if(is_bullish)
      {
         // Para COMPRA: verificar se h√° fundos intermedi√°rios que est√£o muito abaixo da linha
         bool is_significant_low = IsValidPivot(data, i, false, 1); // Buscar fundo
         
         if(is_significant_low && data[i] < (expected_line_value - line_tolerance))
         {
            if(ShowDivergenceValidation)
            {
               PrintControlledLog("LINHA CORTADA (Compra) - Fundo intermedi√°rio na barra " + (string)i);
               cleanLineRejections++;
            }
            return false; // Linha corta um fundo significativo
         }
      }
      else
      {
         // Para VENDA: verificar se h√° topos intermedi√°rios que est√£o muito acima da linha
         bool is_significant_high = IsValidPivot(data, i, true, 1); // Buscar topo
         
         if(is_significant_high && data[i] > (expected_line_value + line_tolerance))
         {
            if(ShowDivergenceValidation)
            {
               PrintControlledLog("LINHA CORTADA (Venda) - Topo intermedi√°rio na barra " + (string)i);
               cleanLineRejections++;
            }
            return false; // Linha corta um topo significativo
         }
      }
   }
   
   return true; // Linha passa limpa
}

//+------------------------------------------------------------------+
//| üî• NOVA FUN√á√ÉO: Busca Rigorosa de Piv√¥s do Mesmo Tipo           |
//+------------------------------------------------------------------+
int FindStrictPivotOfSameType(const double &data[], int current, bool looking_for_high, 
                             int min_distance, int max_lookback, double current_level)
{
   if(!RequireStrictPivots) 
   {
      // Usar busca original se valida√ß√£o rigorosa estiver desabilitada
      for(int i = current - min_distance; i >= current - max_lookback; i--)
      {
         if(i < PivotStrength) break;
         if(IsValidPivot(data, i, looking_for_high, PivotStrength))
         {
            return i;
         }
      }
      return -1;
   }
   
   int best_pivot = -1;
   double best_value = looking_for_high ? -DBL_MAX : DBL_MAX;
   
   for(int i = current - min_distance; i >= current - max_lookback; i--)
   {
      if(i < PivotStrength) break;
      
      // Verificar se √© piv√¥ v√°lido do tipo correto
      if(IsValidPivot(data, i, looking_for_high, PivotStrength))
      {
         if(looking_for_high)
         {
            // Para topos: buscar o mais alto no passado
            if(data[i] > best_value)
            {
               // VENDA: Garantir que o topo atual √© MAIS ALTO que o passado
               if(current_level > data[i]) // Diverg√™ncia: pre√ßo mais alto
               {
                  best_value = data[i];
                  best_pivot = i;
               }
            }
         }
         else
         {
            // Para fundos: buscar o mais alto no passado (para comparar com fundo mais baixo atual)
            if(data[i] > best_value)
            {
               // COMPRA: Garantir que o fundo atual √© MAIS BAIXO que o passado  
               if(current_level < data[i]) // Diverg√™ncia: pre√ßo mais baixo
               {
                  best_value = data[i];
                  best_pivot = i;
               }
            }
         }
      }
   }
   
   return best_pivot;
}

//+------------------------------------------------------------------+
//| üî• NOVA FUN√á√ÉO: Busca de Piv√¥s RSI Correspondentes MELHORADA    |
//+------------------------------------------------------------------+
RSIPivots FindRSIPivotsStrict(const double &rsi_raw[], int price_pivot, int price_current, 
                             bool is_bullish, double price_past, double price_current_val)
{
   RSIPivots result;
   result.valid = false;
   result.rsi_pivot_past = price_pivot;     // Fallback inicial
   result.rsi_pivot_current = price_current; // Fallback inicial
   
   int search_range = MaxSearchRangeForRSI;
   
   // üî• SEMPRE BUSCAR OS PIV√îS RSI MAIS PR√ìXIMOS PRIMEIRO
   int best_rsi_past = -1;
   int best_rsi_current = -1;
   double best_rsi_past_value = is_bullish ? DBL_MAX : -DBL_MAX;
   double best_rsi_current_value = is_bullish ? DBL_MAX : -DBL_MAX;
   
   if(is_bullish)
   {
      // COMPRA: Buscar FUNDOS RSI pr√≥ximos aos fundos de pre√ßo
      
      // 1. Buscar fundo RSI pr√≥ximo ao price_pivot
      for(int i = price_pivot - search_range; i <= price_pivot + search_range; i++)
      {
         if(i >= 1 && i < ArraySize(rsi_raw) - 1)
         {
            if(IsValidPivot(rsi_raw, i, false, 1)) // false = fundo
            {
               if(rsi_raw[i] < best_rsi_past_value) // Buscar o fundo mais baixo
               {
                  best_rsi_past_value = rsi_raw[i];
                  best_rsi_past = i;
               }
            }
         }
      }
      
      // 2. Buscar fundo RSI pr√≥ximo ao price_current
      for(int i = price_current - search_range; i <= price_current + search_range; i++)
      {
         if(i >= 1 && i < ArraySize(rsi_raw) - 1)
         {
            if(IsValidPivot(rsi_raw, i, false, 1)) // false = fundo
            {
               if(rsi_raw[i] < best_rsi_current_value) // Buscar o fundo mais baixo
               {
                  best_rsi_current_value = rsi_raw[i];
                  best_rsi_current = i;
               }
            }
         }
      }
   }
   else
   {
      // VENDA: Buscar TOPOS RSI pr√≥ximos aos topos de pre√ßo
      
      // 1. Buscar topo RSI pr√≥ximo ao price_pivot
      for(int i = price_pivot - search_range; i <= price_pivot + search_range; i++)
      {
         if(i >= 1 && i < ArraySize(rsi_raw) - 1)
         {
            if(IsValidPivot(rsi_raw, i, true, 1)) // true = topo
            {
               if(rsi_raw[i] > best_rsi_past_value) // Buscar o topo mais alto
               {
                  best_rsi_past_value = rsi_raw[i];
                  best_rsi_past = i;
               }
            }
         }
      }
      
      // 2. Buscar topo RSI pr√≥ximo ao price_current
      for(int i = price_current - search_range; i <= price_current + search_range; i++)
      {
         if(i >= 1 && i < ArraySize(rsi_raw) - 1)
         {
            if(IsValidPivot(rsi_raw, i, true, 1)) // true = topo
            {
               if(rsi_raw[i] > best_rsi_current_value) // Buscar o topo mais alto
               {
                  best_rsi_current_value = rsi_raw[i];
                  best_rsi_current = i;
               }
            }
         }
      }
   }
   
   // üî• USAR OS MELHORES PIV√îS ENCONTRADOS (mesmo que n√£o passem na valida√ß√£o rigorosa)
   if(best_rsi_past != -1 && best_rsi_current != -1)
   {
      result.rsi_pivot_past = best_rsi_past;
      result.rsi_pivot_current = best_rsi_current;
      
      // 3. VALIDAR DIVERG√äNCIA APENAS SE HABILITADO
      bool valid_divergence = true;
      if(EnableStrictDivergenceCheck)
      {
         valid_divergence = IsValidDivergenceDirection(price_past, price_current_val, 
                                                      rsi_raw[result.rsi_pivot_past], 
                                                      rsi_raw[result.rsi_pivot_current], is_bullish);
      }
      
      // 4. VALIDAR TRA√áADO LIMPO APENAS SE HABILITADO
      bool clean_line = true;
      if(EnableCleanLineCheck)
      {
         clean_line = LinePassesCleanly(rsi_raw, result.rsi_pivot_past, result.rsi_pivot_current, is_bullish, LineTolerancePercent);
      }
      
      result.valid = valid_divergence && clean_line;
      
      if(result.valid) strictValidationPassed++;
      else strictValidationFailed++;
      
      // üî• SEMPRE USAR OS PIV√îS ENCONTRADOS, mesmo que valida√ß√£o falhe
      // Isso garante linhas mais paralelas
      result.valid = true; // For√ßar como v√°lido para desenhar linha correta
   }
   else
   {
      // üî• FALLBACK MELHORADO: Se n√£o encontrou piv√¥s, buscar o mais pr√≥ximo poss√≠vel
      if(best_rsi_past == -1)
      {
         // Buscar qualquer piv√¥ RSI pr√≥ximo, mesmo que n√£o seja do tipo ideal
         for(int i = price_pivot - search_range; i <= price_pivot + search_range; i++)
         {
            if(i >= 1 && i < ArraySize(rsi_raw) - 1)
            {
               if(IsValidPivot(rsi_raw, i, !is_bullish, 1) || IsValidPivot(rsi_raw, i, is_bullish, 1))
               {
                  result.rsi_pivot_past = i;
                  break;
               }
            }
         }
      }
      
      if(best_rsi_current == -1)
      {
         // Buscar qualquer piv√¥ RSI pr√≥ximo, mesmo que n√£o seja do tipo ideal
         for(int i = price_current - search_range; i <= price_current + search_range; i++)
         {
            if(i >= 1 && i < ArraySize(rsi_raw) - 1)
            {
               if(IsValidPivot(rsi_raw, i, !is_bullish, 1) || IsValidPivot(rsi_raw, i, is_bullish, 1))
               {
                  result.rsi_pivot_current = i;
                  break;
               }
            }
         }
      }
      
      result.valid = true; // Sempre considerar v√°lido para tra√ßar linhas paralelas
      strictValidationFailed++;
   }
   
   return result;
}

//+------------------------------------------------------------------+
//| TODAS AS FUN√á√ïES ORIGINAIS MANTIDAS INTEGRALMENTE               |
//+------------------------------------------------------------------+
double ScaleRSIValue(double rsiValue) 
{ 
   // ‚úÖ MANT√âM ESCALA ORIGINAL 0-100, mas posiciona na zona RSI (30-100)
   return RSI_ZONE_MIN + (rsiValue / 100.0) * (RSI_ZONE_MAX - RSI_ZONE_MIN);
}

double ScaleVolumeValue(double volumeValue, long maxVolume) 
{ 
   if(maxVolume <= 0) return VOLUME_ZONE_MIN; 
   
   // ‚úÖ Volume normalizado para zona 0-25
   double normalizedVolume = (double)volumeValue / (double)maxVolume;
   if(normalizedVolume > 1.0) normalizedVolume = 1.0;
   
   return VOLUME_ZONE_MIN + (normalizedVolume * (VOLUME_ZONE_MAX - VOLUME_ZONE_MIN)); 
}

bool IsBacktest()
{
   return (MQLInfoInteger(MQL_TESTER) || 
           MQLInfoInteger(MQL_OPTIMIZATION) ||
           MQLInfoInteger(MQL_VISUAL_MODE));
}

bool IsValidPivot(const double &data[], int position, bool isHigh, int strength)
{
   // ‚úÖ TEMPO REAL: Permite detec√ß√£o at√© a pen√∫ltima barra (mais responsivo)
   int max_allowed = IsBacktest() ? ArraySize(data) - strength : ArraySize(data) - 1;
   if(position < strength || position >= max_allowed) return false;
   
   for(int i = 1; i <= strength; i++)
   {
      if(isHigh)
      {
         // Verifica passado
         if(data[position] <= data[position - i]) return false;
         
         // Verifica futuro (s√≥ se dispon√≠vel)
         if(position + i < ArraySize(data) && data[position] <= data[position + i])
            return false;
      }
      else
      {
         // Verifica passado  
         if(data[position] >= data[position - i]) return false;
         
         // Verifica futuro (s√≥ se dispon√≠vel)
         if(position + i < ArraySize(data) && data[position] >= data[position + i])
            return false;
      }
   }
   return true;
}

bool IsStrongPivot(const double &data[], int position, bool isHigh, int strength, double min_amplitude)
{
   if(!IsValidPivot(data, position, isHigh, strength)) return false;
   
   double amplitude = 0;
   for(int i = 1; i <= strength; i++)
   {
      if(isHigh)
      {
         // ‚úÖ TEMPO REAL: Usa dados dispon√≠veis
         double left = data[position-i];
         double right = (position+i < ArraySize(data)) ? data[position+i] : data[position-i];
         amplitude = MathMax(amplitude, data[position] - MathMin(left, right));
      }
      else
      {
         // ‚úÖ TEMPO REAL: Usa dados dispon√≠veis
         double left = data[position-i];  
         double right = (position+i < ArraySize(data)) ? data[position+i] : data[position-i];
         amplitude = MathMax(amplitude, MathMax(left, right) - data[position]);
      }
   }
   
   return amplitude >= min_amplitude;
}

bool IsRealDivergence(double price1, double price2, double rsi1, double rsi2, bool is_bullish)
{
   double price_diff_percent = MathAbs((price2 - price1) / price1) * 100.0;
   double rsi_diff = MathAbs(rsi2 - rsi1);
   
   // ‚úÖ VALORES ORIGINAIS MANTIDOS
   if(price_diff_percent < 0.005) return false;  
   if(rsi_diff < 0.3) return false;              
   
   if(is_bullish)
   {
      // Apenas verificar se h√° diverg√™ncia b√°sica
      return (price2 < price1 && rsi2 > rsi1);  // Diverg√™ncia simples
   }
   else
   {
      // Apenas verificar se h√° diverg√™ncia b√°sica
      return (price2 > price1 && rsi2 < rsi1);  // Diverg√™ncia simples
   }
}

bool IsValidTrendContext(const double &price[], int pivot, int current, bool is_bullish)
{
   if(!RequireTrendContext) return true;
   
   int lookback = 15;  // Per√≠odo para an√°lise de tend√™ncia
   if(current < lookback) return true;
   
   // ‚úÖ AN√ÅLISE DE TEND√äNCIA SIMPLES: Verificar dire√ß√£o geral
   double start_price = price[current - lookback];
   double end_price = price[current];
   double trend_slope = (end_price - start_price) / lookback;
   
   // ‚úÖ CONTEXTO ADICIONAL: Verificar se est√° vindo da dire√ß√£o correta
   double mid_price = price[current - lookback/2];
   
   if(is_bullish)
   {
      // Para diverg√™ncia BULLISH: pre√ßo deve estar descendo ou est√°vel
      bool declining_trend = trend_slope <= 0.0001;
      bool came_from_high = mid_price > end_price;  // Veio de cima
      return declining_trend || came_from_high;
   }
   else
   {
      // Para diverg√™ncia BEARISH: pre√ßo deve estar subindo ou est√°vel  
      bool rising_trend = trend_slope >= -0.0001;
      bool came_from_low = mid_price < end_price;   // Veio de baixo
      return rising_trend || came_from_low;
   }
}

bool HasMinimumLineSlope(double price1, double price2, double rsi1, double rsi2, int bars_distance, bool is_bullish)
{
   if(bars_distance <= 1) return false;
   
   // ‚úÖ INCLINA√á√ÉO DO PRE√áO (por barra)
   double price_slope_per_bar = MathAbs(price2 - price1) / bars_distance;
   double price_change_percent = MathAbs((price2 - price1) / price1) * 100.0;
   
   // ‚úÖ INCLINA√á√ÉO DO RSI (por barra)  
   double rsi_slope_per_bar = MathAbs(rsi2 - rsi1) / bars_distance;
   
   // üîß CRIT√âRIOS REEQUILIBRADOS - MAIS RIGOROSOS
   double min_price_change = MinPriceDifference;  // Usar valor do input (agora 0.025)
   double min_rsi_change = RSIMinSlope;           // Usar valor do input (agora 1.0)
   
   bool price_slope_ok = price_change_percent >= min_price_change;
   bool rsi_slope_ok = rsi_slope_per_bar >= (min_rsi_change / bars_distance);
   
   // üî• LOG CONTROLADO - sem spam
   if(ShowDebugInfo && CanPrintLog() && (!price_slope_ok || !rsi_slope_ok))
   {
      PrintControlledLog("INCLINA√á√ÉO INSUFICIENTE - Pre√ßo: " + DoubleToString(price_change_percent, 3) + "% | RSI: " + DoubleToString(rsi_slope_per_bar, 2));
   }
   
   return price_slope_ok && rsi_slope_ok;
}

bool IsValidRSISequence(int current_bar, bool is_bullish)
{
   if(is_bullish)
   {
      // ‚úÖ CONTROLE BULLISH ORIGINAL: Ap√≥s 3 fundos consecutivos, dar cooldown
      if(lastBullishPivotBar > 0 && (current_bar - lastBullishPivotBar) <= 8)
      {
         consecutiveBullishPivots++;
         if(consecutiveBullishPivots >= 3)
         {
            PrintControlledLog("BULLISH REJEITADO - Muitos fundos consecutivos (" + (string)consecutiveBullishPivots + ")");
            return false;
         }
      }
      else
      {
         consecutiveBullishPivots = 0;  // Reset contador
      }
      lastBullishPivotBar = current_bar;
   }
   else
   {
      // ‚úÖ CONTROLE BEARISH ORIGINAL: Ap√≥s 3 topos consecutivos, dar cooldown  
      if(lastBearishPivotBar > 0 && (current_bar - lastBearishPivotBar) <= 8)
      {
         consecutiveBearishPivots++;
         if(consecutiveBearishPivots >= 3)
         {
            PrintControlledLog("BEARISH REJEITADO - Muitos topos consecutivos (" + (string)consecutiveBearishPivots + ")");
            return false;
         }
      }
      else
      {
         consecutiveBearishPivots = 0;  // Reset contador
      }
      lastBearishPivotBar = current_bar;
   }
   
   return true;
}

bool CheckSignificance(double price1, double price2, double rsi1, double rsi2, 
                       bool is_bullish, ENUM_DIVERGENCE_MODE mode)
{
   double rsi_diff = MathAbs(rsi2 - rsi1);
   double price_diff_percent = MathAbs((price2 - price1) / price1) * 100.0;
   
   switch(mode)
   {
      case MODE_SENSITIVE:
         // ‚úÖ VALORES ORIGINAIS MANTIDOS
         return rsi_diff >= 0.05 && price_diff_percent >= 0.0005; 
         
      case MODE_BALANCED:
         // üîß VALORES REEQUILIBRADOS - MAIS RIGOROSOS
         return rsi_diff >= 0.8 && price_diff_percent >= 0.02; 
         
      case MODE_CONSERVATIVE:
         // ‚úÖ VALORES ORIGINAIS MANTIDOS
         return rsi_diff >= MinRSIDifference * 0.3 && price_diff_percent >= MinPriceDifference * 0.3; 
   }
   
   return false;
}

double GetVolumeChangePercent(const long &tick_volume[], int start, int end) 
{ 
   if(end <= start || start < Volume_Period || end >= ArraySize(tick_volume)) return 0.0; 
   
   // ‚úÖ M√âTODO VISUAL MELHORADO: Comparar per√≠odo recente vs anterior
   int compare_period = MathMin(5, (end - start) / 2);  // Per√≠odo din√¢mico
   
   // Volume do per√≠odo recente (ao redor do end)
   long sum_recent = 0;
   for(int i = 0; i < compare_period; i++) 
   {
      if(end - i >= 0) sum_recent += tick_volume[end - i];
   }
   double avg_recent = (double)sum_recent / compare_period;
   
   // Volume do per√≠odo anterior (ao redor do start)  
   long sum_previous = 0;
   for(int i = 0; i < compare_period; i++) 
   {
      if(start - i >= 0) sum_previous += tick_volume[start - i];
   }
   double avg_previous = (double)sum_previous / compare_period;
   
   if(avg_previous <= 0) return 0.0;
   double visual_method = ((avg_recent - avg_previous) / avg_previous) * 100.0;
   
   // ‚úÖ M√âTODO ALTERNATIVO: Volume atual vs m√©dia m√≥vel longa
   long sum_long = 0; 
   for(int i = 0; i < Volume_Period; i++) 
   {
      if(end - i >= 0) sum_long += tick_volume[end - i]; 
   }
   double avg_long = (double)sum_long / Volume_Period;
   double current_vs_avg = avg_previous > 0 ? ((avg_recent - avg_long) / avg_long) * 100.0 : 0.0;
   
   // ‚úÖ USAR O M√âTODO MAIS CONSERVADOR (evita falsos positivos)
   double result = (MathAbs(visual_method) > MathAbs(current_vs_avg)) ? current_vs_avg : visual_method;
   
   return result;
}

bool CheckVolumeConfirmation(bool is_buy, const long &tick_volume[], int start, int end) 
{ 
   double volumeChange = GetVolumeChangePercent(tick_volume, start, end); 
   
   // üî• CORRE√á√ÉO L√ìGICA: AMBAS dire√ß√µes procuram volume ALTO
   bool vol_confirmed = volumeChange >= Volume_Divergence_Min;
   
   return vol_confirmed;
}

bool CheckMinimumVolume(const long &tick_volume[], int position) 
{ 
   if(position < Volume_Period) return true; 
   long totalVolume = 0; 
   for(int i = position - Volume_Period + 1; i <= position; i++) 
      totalVolume += tick_volume[i]; 
   double avgVolume = (double)totalVolume / Volume_Period; 
   return (double)tick_volume[position] >= (avgVolume * Min_Volume_Factor); 
}

double CalculateDivergenceScore(double price1, double price2, double rsi1, double rsi2, 
                               int pivot, int current, const long &volume[], bool is_bullish)
{
   double score = 15; // ‚úÖ VALOR ORIGINAL
   
   // 1. For√ßa da diverg√™ncia RSI (0-30 pontos)
   double rsi_strength = MathAbs(rsi2 - rsi1);
   score += MathMin(rsi_strength * 8, 30); 
   
   // 2. For√ßa da diverg√™ncia pre√ßo (0-25 pontos)
   double price_strength = MathAbs((price2 - price1) / price1) * 100;
   score += MathMin(price_strength * 25, 25); 
   
   // 3. Confirma√ß√£o de volume (0-25 pontos) - SEMPRE D√Å PONTOS
   if(current > pivot && pivot >= Volume_Period && current >= Volume_Period)
   {
      double vol_change = GetVolumeChangePercent(volume, pivot, current);
      // üî• CORRIGIDO: Volume alto para qualquer dire√ß√£o
      if(vol_change > 0.5) // Volume aumentou = for√ßa
         score += 25;
      else if(MathAbs(vol_change) > 0.2)
         score += 20;
      else
         score += 18; 
   }
   else
   {
      score += 22; 
   }
   
   // 4. Posi√ß√£o nos n√≠veis extremos (0-20 pontos) - SEMPRE D√Å PONTOS
   score += 18; 
   
   return score; // Score geralmente ser√° 45-100+
}

//+------------------------------------------------------------------+
//| üî• NOVA FUN√á√ÉO: Volume em Candles Espec√≠ficos                   |
//+------------------------------------------------------------------+
bool CheckCandleDirectionVolume(const double &open[], const double &close[], 
                               const long &volume[], int position, bool for_buy, int lookback = 5)
{
   if(!DetectCandleVolume || position < lookback) return true; // Se desabilitado, sempre aprova
   
   long totalTargetVolume = 0;
   long totalVolume = 0;
   
   for(int i = 0; i < lookback; i++)
   {
      int bar = position - i;
      if(bar < 0) break;
      
      totalVolume += volume[bar];
      
      // Para COMPRA: verificar volume em candles VERDES
      // Para VENDA: verificar volume em candles VERMELHOS
      bool isTargetCandle = for_buy ? (close[bar] > open[bar]) : (close[bar] < open[bar]);
      
      if(isTargetCandle)
         totalTargetVolume += volume[bar];
   }
   
   if(totalVolume == 0) return true; // Se n√£o h√° dados, aprova
   
   double targetVolumePercent = ((double)totalTargetVolume / (double)totalVolume) * 100.0;
   bool confirmed = targetVolumePercent >= CandleVolumeThreshold;
   
   return confirmed;
}

//+------------------------------------------------------------------+
//| üî• NOVA FUN√á√ÉO: Fluxo Institucional                             |
//+------------------------------------------------------------------+
bool CheckInstitutionalVolumeFlow(const double &price_ref[], const long &volume[], 
                                 int pivot, int current, bool for_buy)
{
   if(!DetectInstitutionalFlow || current <= pivot) return true; // Se desabilitado, sempre aprova
   
   // Calcular volume m√©dio no per√≠odo da diverg√™ncia
   long sum_volume = 0;
   int period = current - pivot;
   for(int i = 0; i < period && (current - i) >= 0; i++)
      sum_volume += volume[current - i];
   
   double avg_volume_period = period > 0 ? (double)sum_volume / period : 0;
   
   // Calcular volume m√©dio geral (refer√™ncia)
   long sum_general = 0;
   int general_start = MathMax(0, pivot - Volume_Period);
   for(int i = general_start; i < pivot && i >= 0; i++)
      sum_general += volume[i];
   double avg_volume_general = Volume_Period > 0 ? (double)sum_general / Volume_Period : 1;
   
   // Calcular ratio institucional
   double volume_ratio = avg_volume_general > 0 ? (avg_volume_period / avg_volume_general) * 100.0 : 100.0;
   
   // Mudan√ßa no pre√ßo para validar se houve movimento significativo
   double price_change_percent = MathAbs((price_ref[current] - price_ref[pivot]) / price_ref[pivot]) * 100.0;
   
   // Crit√©rio: Volume institucional + movimento m√≠nimo (relaxado)
   bool institutional_flow = (volume_ratio >= InstitutionalVolumeMin) && (price_change_percent >= 0.2);
   
   return institutional_flow;
}

//+------------------------------------------------------------------+
//| üîß NOVA FUN√á√ÉO: Verificar "Esticada" do RSI (C√≠rculos 1 e 2)    |
//+------------------------------------------------------------------+
bool CheckRSITravelDistance(const double &rsi[], int start_bar, int end_bar, bool is_bullish)
{
   if(!EnableRSITravelCheck) return true; // ‚úÖ Se desabilitado, sempre aprova
   
   if(start_bar == end_bar) return false;
   
   double start_rsi = rsi[start_bar];
   double end_rsi = rsi[end_bar];
   
   // Encontrar o n√≠vel "neutro" (50) e verificar se RSI se aproximou demais
   for(int i = MathMin(start_bar, end_bar) + 1; i < MathMax(start_bar, end_bar); i++)
   {
      if(is_bullish)
      {
         // Para diverg√™ncia bullish, verificar se RSI subiu demais (se aproximou muito do 50)
         double max_allowed_rsi = MathMax(start_rsi, end_rsi) + RSIMaxDeviation;
         if(rsi[i] > max_allowed_rsi && rsi[i] > 45.0) // Se passou muito de 45 (perto do 50)
         {
            PrintControlledLog("RSI ESTICOU DEMAIS (Bullish) - Barra " + (string)i + " | RSI: " + DoubleToString(rsi[i], 1));
            return false;
         }
      }
      else
      {
         // Para diverg√™ncia bearish, verificar se RSI desceu demais (se aproximou muito do 50)
         double min_allowed_rsi = MathMin(start_rsi, end_rsi) - RSIMaxDeviation;
         if(rsi[i] < min_allowed_rsi && rsi[i] < 55.0) // Se passou muito de 55 (perto do 50)
         {
            PrintControlledLog("RSI ESTICOU DEMAIS (Bearish) - Barra " + (string)i + " | RSI: " + DoubleToString(rsi[i], 1));
            return false;
         }
      }
   }
   
   return true;
}

//+------------------------------------------------------------------+
//| üîß NOVA FUN√á√ÉO: Detectar Linha Cortando RSI (C√≠rculo 3)         |
//+------------------------------------------------------------------+
bool CheckRSILineObstruction(const double &rsi[], int start_bar, int end_bar, bool is_bullish)
{
   if(!EnableRSIObstructionCheck) return true; // üî• NOVO: Se desabilitado, sempre aprova
   
   if(start_bar == end_bar) return false;
   if(start_bar > end_bar) { int temp = start_bar; start_bar = end_bar; end_bar = temp; }
   
   double start_rsi = rsi[start_bar];
   double end_rsi = rsi[end_bar];
   int significant_obstructions = 0;
   int max_obstructions = RSIMaxObstructions; // üîß REEQUILIBRADO: Agora usa 2
   
   for(int i = start_bar + 1; i < end_bar; i++)
   {
      // Calcular onde a linha deveria estar neste ponto
      double line_ratio = (double)(i - start_bar) / (double)(end_bar - start_bar);
      double expected_rsi_on_line = start_rsi + (end_rsi - start_rsi) * line_ratio;
      
      // Verificar se h√° piv√¥ significativo que corta a linha
      bool is_rsi_pivot = IsValidPivot(rsi, i, !is_bullish, 1); // Piv√¥ no sentido oposto
      
      if(is_rsi_pivot)
      {
         if(is_bullish)
         {
            // Diverg√™ncia bullish: verificar se h√° topo no RSI que corta a linha
            if(rsi[i] > expected_rsi_on_line + 3.0) // Topo 3 pontos acima da linha
            {
               significant_obstructions++;
            }
         }
         else
         {
            // Diverg√™ncia bearish: verificar se h√° fundo no RSI que corta a linha
            if(rsi[i] < expected_rsi_on_line - 3.0) // Fundo 3 pontos abaixo da linha
            {
               significant_obstructions++;
            }
         }
         
         if(significant_obstructions > max_obstructions)
         {
            PrintControlledLog("LINHA RSI CORTADA - Muitas obstru√ß√µes (" + (string)significant_obstructions + ")");
            return false;
         }
      }
   }
   
   return true;
}

//+------------------------------------------------------------------+
//| üîß NOVA FUN√á√ÉO: Verificar Inclina√ß√£o Real do RSI (C√≠rculo 4)    |
//+------------------------------------------------------------------+
bool CheckRSILineSlope(double rsi1, double rsi2, int bars_distance, bool is_bullish)
{
   if(!EnableRSISlopeCheck) return true; // üî• NOVO: Se desabilitado, sempre aprova
   
   if(bars_distance <= 1) return false;
   
   double rsi_diff = MathAbs(rsi2 - rsi1);
   double min_rsi_slope = RSIMinSlope; // üîß REEQUILIBRADO: Agora usa 1.0
   double min_rsi_slope_per_bar = min_rsi_slope / bars_distance;
   
   // Verificar se h√° inclina√ß√£o real no RSI
   double actual_rsi_slope_per_bar = rsi_diff / bars_distance;
   
   if(actual_rsi_slope_per_bar < min_rsi_slope_per_bar)
   {
      PrintControlledLog("RSI MUITO RETO - Diferen√ßa RSI: " + DoubleToString(rsi_diff, 1) + " | Dist√¢ncia: " + (string)bars_distance);
      return false;
   }
   
   // Verificar dire√ß√£o correta da diverg√™ncia
   if(is_bullish)
   {
      // Diverg√™ncia bullish: RSI deve estar subindo (rsi2 > rsi1)
      if(rsi2 <= rsi1)
      {
         PrintControlledLog("RSI DIRE√á√ÉO ERRADA (Bullish) - RSI1: " + DoubleToString(rsi1, 1) + " | RSI2: " + DoubleToString(rsi2, 1));
         return false;
      }
   }
   else
   {
      // Diverg√™ncia bearish: RSI deve estar descendo (rsi2 < rsi1)
      if(rsi2 >= rsi1)
      {
         PrintControlledLog("RSI DIRE√á√ÉO ERRADA (Bearish) - RSI1: " + DoubleToString(rsi1, 1) + " | RSI2: " + DoubleToString(rsi2, 1));
         return false;
      }
   }
   
   return true;
}

//+------------------------------------------------------------------+
//| üîß NOVA FUN√á√ÉO: Verifica√ß√£o Completa de Qualidade RSI           |
//+------------------------------------------------------------------+
bool CheckRSIQuality(const double &rsi[], int start_bar, int end_bar, bool is_bullish)
{
   // 1. Verificar se RSI n√£o "esticou" demais (C√≠rculos 1 e 2)
   if(!CheckRSITravelDistance(rsi, start_bar, end_bar, is_bullish))
      return false;
   
   // 2. Verificar se linha n√£o √© cortada por obstru√ß√µes (C√≠rculo 3)
   if(!CheckRSILineObstruction(rsi, start_bar, end_bar, is_bullish))
      return false;
   
   // 3. Verificar inclina√ß√£o real do RSI (C√≠rculo 4)
   if(!CheckRSILineSlope(rsi[start_bar], rsi[end_bar], MathAbs(end_bar - start_bar), is_bullish))
      return false;
   
   return true;
}

//+------------------------------------------------------------------+
//| üîß NOVA FUN√á√ÉO: Verifica√ß√£o de Linha Limpa (OPCIONAL)           |
//+------------------------------------------------------------------+
bool IsCleanDivergenceLine(const double &price[], const double &rsi[], int start_bar, int end_bar, bool is_bullish)
{
   if(!UseCleanerLines) return true; // ‚úÖ Se desabilitado, considera todas as linhas como limpas
   
   if(start_bar == end_bar) return false;
   if(start_bar > end_bar) { int temp = start_bar; start_bar = end_bar; end_bar = temp; } // Garantir ordem
   
   double start_price = price[start_bar];
   double end_price = price[end_bar];
   
   // üîß TOLER√ÇNCIA MUITO ALTA para n√£o eliminar sinais
   double price_tolerance = MathAbs(end_price - start_price) * (CleanLineTolerancePercent / 100.0);
   
   int obstructions_found = 0; // Contar obstru√ß√µes
   
   for(int i = start_bar + 1; i < end_bar; i++)
   {
      if(is_bullish)
      {
         // Diverg√™ncia Bullish: verificar se linha passa muito acima de fundos intermedi√°rios
         bool is_significant_low = IsValidPivot(price, i, false, 1);
         
         if(is_significant_low)
         {
            // Calcular onde a linha deveria estar neste ponto
            double line_ratio = (double)(i - start_bar) / (double)(end_bar - start_bar);
            double expected_price_on_line = start_price + (end_price - start_price) * line_ratio;
            
            // Se o pre√ßo real est√° MUITO abaixo da linha esperada
            if(price[i] < (expected_price_on_line - price_tolerance))
            {
               obstructions_found++;
               
               // üîß S√ì REJEITA se h√° MUITAS obstru√ß√µes
               if(obstructions_found > MaxLineObstructions)
               {
                  PrintControlledLog("LINHA REJEITADA (Bullish) - Muitas obstru√ß√µes (" + (string)obstructions_found + ")");
                  return false;
               }
            }
         }
      }
      else
      {
         // Diverg√™ncia Bearish: verificar se linha passa muito abaixo de topos intermedi√°rios
         bool is_significant_high = IsValidPivot(price, i, true, 1);
         
         if(is_significant_high)
         {
            double line_ratio = (double)(i - start_bar) / (double)(end_bar - start_bar);
            double expected_price_on_line = start_price + (end_price - start_price) * line_ratio;
            
            // Se o pre√ßo real est√° MUITO acima da linha esperada
            if(price[i] > (expected_price_on_line + price_tolerance))
            {
               obstructions_found++;
               
               // üîß S√ì REJEITA se h√° MUITAS obstru√ß√µes
               if(obstructions_found > MaxLineObstructions)
               {
                  PrintControlledLog("LINHA REJEITADA (Bearish) - Muitas obstru√ß√µes (" + (string)obstructions_found + ")");
                  return false;
               }
            }
         }
      }
   }
   
   return true;
}

//+------------------------------------------------------------------+
//| üî• FUN√á√ÉO ENHANCED CORRIGIDA: Confirma√ß√£o de Volume Melhorada   |
//+------------------------------------------------------------------+
bool CheckVolumeConfirmationEnhanced(bool is_buy, const double &open[], const double &close[], 
                                    const double &price[], const long &tick_volume[], int start, int end) 
{
   if(!UseEnhancedVolumeAnalysis)
   {
      // Usar m√©todo original se enhanced estiver desabilitado
      double volumeChange = GetVolumeChangePercent(tick_volume, start, end);
      
      // üî• CORRE√á√ÉO L√ìGICA: AMBAS dire√ß√µes procuram volume ALTO (positivo)
      bool vol_confirmed = volumeChange >= Volume_Divergence_Min;
      
      // üî• NOVO: Mostrar % original no gr√°fico (posi√ß√£o central) - S√ì SE HABILITADO
      if(ShowVolumeDebugOnChart)
      {
         string check = vol_confirmed ? "‚úì" : "‚úó";
         string text = check + "Vol:" + DoubleToString(volumeChange, 1) + "%";
         color textColor = vol_confirmed ? clrYellow : clrDarkGray;
         CreateVolumeDebugText(iTime(NULL, 0, end), iClose(NULL, 0, end), text, textColor);
      }
      
      return vol_confirmed;
   }
   
   // üî• AN√ÅLISE ENHANCED CORRIGIDA: Combinar m√∫ltiplos crit√©rios
   
   // 1. M√©todo original como base (CORRIGIDO - ambas dire√ß√µes procuram volume alto)
   double volumeChange = GetVolumeChangePercent(tick_volume, start, end);
   bool original_ok = volumeChange >= (Volume_Divergence_Min * 0.5); // üî• SEMPRE positivo para ambas dire√ß√µes
   
   // 2. Volume na dire√ß√£o dos candles (diferenciado por dire√ß√£o)
   bool candle_direction_ok = CheckCandleDirectionVolume(open, close, tick_volume, end, is_buy);
   
   // 3. Fluxo institucional (volume alto independente da dire√ß√£o)
   bool institutional_ok = CheckInstitutionalVolumeFlow(price, tick_volume, start, end, is_buy);
   
   // üéØ SISTEMA DE PONTUA√á√ÉO RELAXADO: Pelo menos 1 de 3 crit√©rios devem passar
   int passed_criteria = 0;
   if(original_ok) passed_criteria++;
   if(candle_direction_ok) passed_criteria++;
   if(institutional_ok) passed_criteria++;
   
   bool enhanced_confirmed = passed_criteria >= 1; // üî• RELAXADO: Era 2, agora 1
   
   if(enhanced_confirmed) enhancedVolumeUsed++;
   
   return enhanced_confirmed;
}

//+------------------------------------------------------------------+
//| üîß NOVA FUN√á√ÉO: Busca Inteligente de Piv√¥s (OPCIONAL)           |
//+------------------------------------------------------------------+
int FindBestPivotForCleanLine(const double &price[], const double &rsi_raw[], const long &tick_volume[], 
                             int current, bool is_bullish, double level, int pivot_strength)
{
   // üîß CORRE√á√ÉO: Para COMPRA procurar FUNDO no passado, para VENDA procurar TOPO no passado
   bool lookingForHighInPast = !is_bullish;  // COMPRA procura fundos, VENDA procura topos
   
   if(!UseCleanerLines) 
   {
      // ‚úÖ BUSCA ORIGINAL CORRIGIDA
      for(int i = current - MinDistanceBetweenPivots; i >= current - DivergenceLookback; i--)
      {
         if(i < pivot_strength) break;
         
         // üîß CORRIGIDO: Buscar tipo correto de piv√¥
         bool priceIsPivot = IsValidPivot(price, i, lookingForHighInPast, pivot_strength);
         bool rsiIsPivot = IsValidPivot(rsi_raw, i, lookingForHighInPast, pivot_strength);
         
         if(priceIsPivot && rsiIsPivot)
         {
            // üîß CORRIGIDO: Verificar n√≠vel correto para o tipo de diverg√™ncia
            bool level_ok;
            if(is_bullish) {
               // COMPRA: RSI no passado deve estar em regi√£o baixa (oversold)
               level_ok = (rsi_raw[i] < level);
            } else {
               // VENDA: RSI no passado deve estar em regi√£o alta (overbought)  
               level_ok = (rsi_raw[i] > level);
            }
            
            if(level_ok && IsStrongPivot(rsi_raw, i, lookingForHighInPast, pivot_strength, MinPivotAmplitude))
            {
               return i; // ‚úÖ PARA NO PRIMEIRO (comportamento original)
            }
         }
      }
      return -1;
   }
   
   // üîß BUSCA INTELIGENTE CORRIGIDA
   int best_pivot = -1;
   double best_score = -1;
   
   for(int i = current - MinDistanceBetweenPivots; i >= current - DivergenceLookback; i--)
   {
      if(i < pivot_strength) break;
      
      bool priceIsPivot = IsValidPivot(price, i, lookingForHighInPast, pivot_strength);
      bool rsiIsPivot = IsValidPivot(rsi_raw, i, lookingForHighInPast, pivot_strength);
      
      if(priceIsPivot && rsiIsPivot)
      {
         bool level_ok;
         if(is_bullish) {
            level_ok = (rsi_raw[i] < level);  // COMPRA: RSI baixo no passado
         } else {
            level_ok = (rsi_raw[i] > level);  // VENDA: RSI alto no passado
         }
         
         if(level_ok && IsStrongPivot(rsi_raw, i, lookingForHighInPast, pivot_strength, MinPivotAmplitude))
         {
            // üîß AVALIAR QUALIDADE DA LINHA
            bool would_have_clean_line = IsCleanDivergenceLine(price, rsi_raw, i, current, is_bullish);
            
            // üîß CALCULAR SCORE
            double line_score = 30; // Base
            
            // üîß BONUS CORRIGIDO: Verificar diverg√™ncia real
            if(is_bullish) {
               // COMPRA: Pre√ßo atual < passado E RSI atual > passado
               if(price[current] < price[i] && rsi_raw[current] > rsi_raw[i])
                  line_score += 40;
            } else {
               // VENDA: Pre√ßo atual > passado E RSI atual < passado  
               if(price[current] > price[i] && rsi_raw[current] < rsi_raw[i])
                  line_score += 40;
            }
            
            // Bonus por linha limpa
            if(would_have_clean_line)
               line_score += 20;
            
            // Bonus por for√ßa da diverg√™ncia
            double rsi_diff = MathAbs(rsi_raw[current] - rsi_raw[i]);
            line_score += rsi_diff;
            
            // Bonus por proximidade (piv√¥s mais recentes s√£o melhores)
            line_score += (DivergenceLookback - (current - i)) * 0.5;
            
            if(line_score > best_score)
            {
               best_pivot = i;
               best_score = line_score;
            }
         }
      }
   }
   
   return best_pivot;
}

//+------------------------------------------------------------------+
//| üî• NOVA FUN√á√ÉO: Busca de Piv√¥s Flex√≠vel (CORRE√á√ÉO PRINCIPAL)    |
//+------------------------------------------------------------------+
bool FindFlexiblePivots(const double &price[], const double &rsi_raw[], int current, bool is_bullish, 
                       int pivot_strength, bool &currentPriceIsPivot, bool &currentRsiIsPivot)
{
   currentPriceIsPivot = false;
   currentRsiIsPivot = false;
   
   // üîß CORRE√á√ÉO: Para diverg√™ncia, current deve ser piv√¥ do MESMO tipo
   // COMPRA: current deve ser FUNDO (isHigh = false)
   // VENDA: current deve ser TOPO (isHigh = true)
   bool lookingForHigh = !is_bullish;  // COMPRA procura fundos, VENDA procura topos
   
   if(!UseFlexiblePivots)
   {
      // üîß L√ìGICA CORRIGIDA: Para diverg√™ncia, current deve ser piv√¥ do tipo correto
      currentPriceIsPivot = IsValidPivot(price, current, lookingForHigh, pivot_strength);
      currentRsiIsPivot = IsValidPivot(rsi_raw, current, lookingForHigh, pivot_strength);
      return currentPriceIsPivot && currentRsiIsPivot;
   }
   
   // üî• L√ìGICA FLEX√çVEL CORRIGIDA: Procurar piv√¥s do tipo correto
   int search_range = PivotSearchRange;
   
   // Procurar piv√¥ de PRE√áO em ¬±range barras ao redor do current
   for(int p = current - search_range; p <= current + search_range; p++)
   {
      if(p >= 0 && p < ArraySize(price) && IsValidPivot(price, p, lookingForHigh, pivot_strength))
      {
         currentPriceIsPivot = true;
         break;
      }
   }
   
   // Procurar piv√¥ de RSI em ¬±range barras ao redor do current  
   for(int r = current - search_range; r <= current + search_range; r++)
   {
      if(r >= 0 && r < ArraySize(rsi_raw) && IsValidPivot(rsi_raw, r, lookingForHigh, pivot_strength))
      {
         currentRsiIsPivot = true;
         break;
      }
   }
   
   return currentPriceIsPivot && currentRsiIsPivot;
}

//+------------------------------------------------------------------+
//| üî• FUN√á√ÉO PRINCIPAL: CheckClassicDivergence RIGOROSA            |
//+------------------------------------------------------------------+
int CheckClassicDivergence(const double &price[], const double &rsi_raw[], const long &tick_volume[], 
                          const double &open[], const double &close[], int current, bool is_bullish)
{
   if(current < DivergenceLookback) return -1;

   int pivot_strength = (DivergenceMode == MODE_CONSERVATIVE) ? PivotStrength + 1 : PivotStrength;
   
   // ‚úÖ USAR sempre RSI raw (0-100) para compara√ß√µes de n√≠vel
   double level = is_bullish ? (OnlyExtremeLevels ? OversoldLevel : 45.0) : (OnlyExtremeLevels ? OverboughtLevel : 55.0);
   
   // üîß BUSCA INTELIGENTE (se ativada) ou ORIGINAL (se desativada)
   int pivot = FindBestPivotForCleanLine(price, rsi_raw, tick_volume, current, is_bullish, level, pivot_strength);
   
   if(pivot > 0)
   {
      // üî• L√ìGICA: Piv√¥s flex√≠veis ou r√≠gidos
      bool currentPriceIsPivot = false;
      bool currentRsiIsPivot = false;
      bool pivotsFound = FindFlexiblePivots(price, rsi_raw, current, is_bullish, pivot_strength, currentPriceIsPivot, currentRsiIsPivot);
      
      // üîß CONDI√á√ïES DE DIVERG√äNCIA ORIGINAIS
      bool price_condition, rsi_condition, level_condition;
      
      if(is_bullish) {
         // COMPRA: Pre√ßo faz fundo mais baixo, RSI faz fundo mais alto
         price_condition = (price[current] < price[pivot]);   // Fundo mais baixo
         rsi_condition = (rsi_raw[current] > rsi_raw[pivot]); // RSI mais alto (diverg√™ncia)
         level_condition = (rsi_raw[current] < level);        // Current ainda em regi√£o baixa
      } else {
         // VENDA: Pre√ßo faz topo mais alto, RSI faz topo mais baixo
         price_condition = (price[current] > price[pivot]);   // Topo mais alto  
         rsi_condition = (rsi_raw[current] < rsi_raw[pivot]); // RSI mais baixo (diverg√™ncia)
         level_condition = (rsi_raw[current] > level);        // Current ainda em regi√£o alta
      }
      
      if(price_condition && rsi_condition && level_condition)
      {
         if(IsRealDivergence(price[pivot], price[current], rsi_raw[pivot], rsi_raw[current], is_bullish))
         {
            if(IsValidRSISequence(current, is_bullish))
            {
               if(HasMinimumLineSlope(price[pivot], price[current], rsi_raw[pivot], rsi_raw[current], current - pivot, is_bullish))
               {
                  // üîß LINHA LIMPA: S√≥ se habilitado
                  bool cleanLine = true;
                  if(RequireCleanLine || UseCleanerLines)
                     cleanLine = IsCleanDivergenceLine(price, rsi_raw, pivot, current, is_bullish);
                  
                  if(cleanLine && pivotsFound)
                  {
                     if(CheckSignificance(price[pivot], price[current], rsi_raw[pivot], rsi_raw[current], is_bullish, DivergenceMode))
                     {
                        if(IsValidTrendContext(price, pivot, current, is_bullish))
                        {
                           // üîß VERIFICA√á√ÉO: Qualidade do RSI (resolve problemas dos c√≠rculos 1, 2, 3 e 4)
                           if(!CheckRSIQuality(rsi_raw, pivot, current, is_bullish))
                           {
                              PrintControlledLog("RSI QUALIDADE REJEITADA - Problemas de tra√ßado detectados");
                              return -1; // Rejeita esta diverg√™ncia
                           }
                           
                           double quality_score = CalculateDivergenceScore(price[pivot], price[current], 
                                                                          rsi_raw[pivot], rsi_raw[current],
                                                                          pivot, current, tick_volume, is_bullish);
                           
                           // üîß SCORE MUITO MAIS RIGOROSO - Reduzir sinais
                           double required_score = is_bullish ? (MinQualityScore * 1.2) : (MinQualityScore * 1.1);
                           
                           if(quality_score >= required_score)
                           {
                              // üî• LOG CONTROLADO - sem spam
                              string divType = is_bullish ? "BULLISH" : "BEARISH";
                              PrintControlledLog("DIVERG√äNCIA " + divType + " RIGOROSA na barra " + (string)current + " | Score: " + DoubleToString(quality_score, 1));
                              
                              return pivot;
                           }
                        }
                     }
                  }
               }
            }
         }
      }
   }
   
   return -1;
}

void CreateStar(datetime time, double price, bool isBuy) 
{ 
   starCounter++; 
   string starName = "RSI_Volume_Star_" + (string)starCounter + (string)TimeCurrent(); 
   if(ObjectCreate(0, starName, OBJ_ARROW_CHECK, 0, time, price))
   {
      ObjectSetInteger(0, starName, OBJPROP_ARROWCODE, SYMBOL_STAR);
      ObjectSetInteger(0, starName, OBJPROP_WIDTH, 4);
      ObjectSetInteger(0, starName, OBJPROP_SELECTABLE, false);
      if(isBuy) 
         ObjectSetInteger(0, starName, OBJPROP_COLOR, clrGold);
      else 
         ObjectSetInteger(0, starName, OBJPROP_COLOR, clrMagenta);
   }
   ChartRedraw(); 
}

void CreateVolumeDebugText(datetime time, double price, string text, color textColor)
{
   // üî• MANTIDO: Fun√ß√£o ativa para mostrar textos no gr√°fico (an√°lise)
   if(!ShowVolumeDebugOnChart && !ShowDetailedVolumeInfo) return;
   
   // ‚úÖ Controlar quantidade de textos para evitar polui√ß√£o
   if(volumeTextsCreated >= MaxVolumeTextsOnChart)
   {
      // Remove textos mais antigos quando atingir o limite
      string oldObjName = "VolumeDebug_" + (string)(volumeTextsCreated - MaxVolumeTextsOnChart);
      ObjectDelete(0, oldObjName);
   }
   
   string objName = "VolumeDebug_" + (string)volumeTextsCreated + "_" + (string)time;
   volumeTextsCreated++;
   
   if(ObjectCreate(0, objName, OBJ_TEXT, 0, time, price))
   {
      ObjectSetInteger(0, objName, OBJPROP_COLOR, textColor);
      
      // üî• DECIDIR TAMANHO DA FONTE: Confirma√ß√µes grandes, % pequenos
      if(StringFind(text, "‚≠ê") >= 0) // Se √© texto de confirma√ß√£o
      {
         ObjectSetInteger(0, objName, OBJPROP_FONTSIZE, 12); // Grande para confirma√ß√µes
         ObjectSetString(0, objName, OBJPROP_FONT, "Arial Bold");
      }
      else // % detalhados
      {
         ObjectSetInteger(0, objName, OBJPROP_FONTSIZE, 8); // Pequeno para %
         ObjectSetString(0, objName, OBJPROP_FONT, "Arial");
      }
      
      ObjectSetString(0, objName, OBJPROP_TEXT, text);
      ObjectSetInteger(0, objName, OBJPROP_ANCHOR, ANCHOR_LEFT_UPPER);
      ObjectSetInteger(0, objName, OBJPROP_SELECTABLE, false); // ‚úÖ N√£o selecion√°vel
      ObjectSetInteger(0, objName, OBJPROP_HIDDEN, true); // ‚úÖ Oculto na lista de objetos
   }
}

void CreateVolumeCircle(datetime time, double volume_value, bool is_buy)
{
   if(!ShowVolumeCircles) return;
   
   starCounter++; // Usar mesmo contador para evitar conflitos
   string circleName = "VolumeCircle_" + (string)starCounter + (string)TimeCurrent();
   
   if(ObjectCreate(0, circleName, OBJ_ARROW, 0, time, volume_value))
   {
      ObjectSetInteger(0, circleName, OBJPROP_ARROWCODE, 159); // C√≥digo de bolinha
      ObjectSetInteger(0, circleName, OBJPROP_WIDTH, 3);
      ObjectSetInteger(0, circleName, OBJPROP_SELECTABLE, false);
      ObjectSetInteger(0, circleName, OBJPROP_HIDDEN, true);
      
      if(is_buy)
         ObjectSetInteger(0, circleName, OBJPROP_COLOR, clrLimeGreen);
      else
         ObjectSetInteger(0, circleName, OBJPROP_COLOR, clrRed);
   }
}

void CreateRSILine(datetime time1, double rsi1, datetime time2, double rsi2, bool is_bullish) 
{ 
   lineCounter++; 
   string line_name = "div_line_rsi_" + (string)lineCounter + (string)TimeCurrent(); 
   if(ObjectCreate(0, line_name, OBJ_TREND, 1, time1, rsi1, time2, rsi2))  // Subwindow 1 = RSI
   { 
      ObjectSetInteger(0, line_name, OBJPROP_COLOR, clrYellow); 
      ObjectSetInteger(0, line_name, OBJPROP_STYLE, STYLE_SOLID); 
      ObjectSetInteger(0, line_name, OBJPROP_WIDTH, 3); 
      ObjectSetInteger(0, line_name, OBJPROP_RAY_RIGHT, false); 
      ObjectSetInteger(0, line_name, OBJPROP_SELECTABLE, false);
      ObjectSetInteger(0, line_name, OBJPROP_HIDDEN, true);
   } 
}

void CreatePriceLine(datetime time1, double price1, datetime time2, double price2, bool is_bullish) 
{ 
   lineCounter++; 
   string line_name = "div_line_price_" + (string)lineCounter + (string)TimeCurrent(); 
   if(ObjectCreate(0, line_name, OBJ_TREND, 0, time1, price1, time2, price2)) 
   { 
      ObjectSetInteger(0, line_name, OBJPROP_COLOR, is_bullish ? clrLimeGreen : clrRed); 
      ObjectSetInteger(0, line_name, OBJPROP_STYLE, STYLE_SOLID); 
      ObjectSetInteger(0, line_name, OBJPROP_WIDTH, 2); 
      ObjectSetInteger(0, line_name, OBJPROP_RAY_RIGHT, false); 
      ObjectSetInteger(0, line_name, OBJPROP_SELECTABLE, false);
      ObjectSetInteger(0, line_name, OBJPROP_HIDDEN, true);
   } 
}

//+------------------------------------------------------------------+
//| Initialization function REEQUILIBRADA                           |
//+------------------------------------------------------------------+
int OnInit()
{
   // ‚úÖ LICEN√áA AJUSTADA: Conta "0" = Universal
   long currentAccount = AccountInfoInteger(ACCOUNT_LOGIN);
   datetime currentTime = TimeCurrent();
   
   // Verificar se √© licen√ßa universal (conta = 0) ou espec√≠fica
   bool isUniversalLicense = (StringToInteger(licenseAccount) == 0);
   bool accountValid = isUniversalLicense || (currentAccount == StringToInteger(licenseAccount));
   bool timeValid = (currentTime <= licenseExpiration);
   
   if (!accountValid || !timeValid) 
   {
      string licenseType = isUniversalLicense ? "UNIVERSAL" : "ESPEC√çFICA";
      string accountInfo = isUniversalLicense ? "Qualquer conta" : ("Conta: " + licenseAccount);
      
      Print("üîí LICEN√áA ", licenseType, " inv√°lida ou expirada!");
      Print("   üìã Configura√ß√£o: ", accountInfo);
      Print("   üóìÔ∏è Expira√ß√£o: ", TimeToString(licenseExpiration));
      Print("   üîç Conta atual: ", currentAccount);
      Print("   üïí Data atual: ", TimeToString(currentTime));
      Print("   ‚ùå Status: ", accountValid ? "Conta OK" : "Conta inv√°lida", " | ", timeValid ? "Tempo OK" : "EXPIRADO");
      
      ObjectsDeleteAll(0, "RSI_Volume_Star_");  
      ObjectsDeleteAll(0, "div_line_price_");  
      ObjectsDeleteAll(0, "div_line_rsi_");     // üî• NOVO: Limpar linhas do RSI
      ObjectsDeleteAll(0, "VolumeDebug_");  
      ChartRedraw();
      
      string errorMsg = "üîí LICEN√áA " + licenseType + " " + (timeValid ? "inv√°lida!" : "EXPIRADA!");
      Comment(errorMsg);
      Alert(errorMsg);
      return INIT_FAILED;
   }
   
   // ‚úÖ LICEN√áA V√ÅLIDA - Mostrar informa√ß√µes (LOG √öNICO)
   string licenseType = isUniversalLicense ? "UNIVERSAL" : "ESPEC√çFICA";
   Print("‚úÖ LICEN√áA ", licenseType, " V√ÅLIDA!");
   Print("   üìã Conta: ", isUniversalLicense ? "Qualquer conta (modo universal)" : licenseAccount);
   Print("   üóìÔ∏è V√°lida at√©: ", TimeToString(licenseExpiration));

   SetIndexBuffer(0, RSIBuffer, INDICATOR_DATA);
   SetIndexBuffer(1, BuyBuffer, INDICATOR_DATA);
   SetIndexBuffer(2, SellBuffer, INDICATOR_DATA);
   SetIndexBuffer(3, RSILineBuffer, INDICATOR_DATA);
   SetIndexBuffer(4, VolumeBuffer, INDICATOR_DATA);
   SetIndexBuffer(5, VolumeAvgBuffer, INDICATOR_DATA);
   SetIndexBuffer(6, VolumeBuyConfirmBuffer, INDICATOR_DATA);
   SetIndexBuffer(7, VolumeSellConfirmBuffer, INDICATOR_DATA);
   SetIndexBuffer(8, DividerBuffer, INDICATOR_DATA);
   
   // üî• CR√çTICO v2.3.8: Buffers EA (9 e 10) SEMPRE como INDICATOR_DATA
   SetIndexBuffer(9, BuySignalConfirmedBuffer, INDICATOR_DATA);
   SetIndexBuffer(10, SellSignalConfirmedBuffer, INDICATOR_DATA);
   
   SetIndexBuffer(11, RawRSIBuffer, INDICATOR_CALCULATIONS);
   SetIndexBuffer(12, BuyStarBacktestBuffer, INDICATOR_DATA);
   SetIndexBuffer(13, SellStarBacktestBuffer, INDICATOR_DATA);

   PlotIndexSetInteger(1, PLOT_ARROW, 233);      
   PlotIndexSetInteger(2, PLOT_ARROW, 234);      
   PlotIndexSetInteger(1, PLOT_LINE_COLOR, clrLimeGreen);  
   PlotIndexSetInteger(2, PLOT_LINE_COLOR, clrRed);        
   PlotIndexSetInteger(6, PLOT_ARROW, 159);      
   PlotIndexSetInteger(7, PLOT_ARROW, 159);
   PlotIndexSetInteger(12, PLOT_ARROW, 159);     
   PlotIndexSetInteger(13, PLOT_ARROW, 159);
   
   PlotIndexSetDouble(1, PLOT_EMPTY_VALUE, 0);
   PlotIndexSetDouble(2, PLOT_EMPTY_VALUE, 0);
   PlotIndexSetDouble(3, PLOT_EMPTY_VALUE, 0);
   PlotIndexSetDouble(6, PLOT_EMPTY_VALUE, 0);
   PlotIndexSetDouble(7, PLOT_EMPTY_VALUE, 0);
   
   // üî• CR√çTICO v2.3.8: Buffers EA com DRAW_NONE (invis√≠veis mas acess√≠veis)
   PlotIndexSetDouble(9, PLOT_EMPTY_VALUE, 0);
   PlotIndexSetDouble(10, PLOT_EMPTY_VALUE, 0);
   
   PlotIndexSetDouble(12, PLOT_EMPTY_VALUE, 0);
   PlotIndexSetDouble(13, PLOT_EMPTY_VALUE, 0);

   RSIHandle = iRSI(NULL, NULL, RSI_Period, RSI_Applied);
   if(RSIHandle == INVALID_HANDLE) { return INIT_FAILED; }
   
   string mode_name = "";
   switch(DivergenceMode)
   {
      case MODE_SENSITIVE: mode_name = "SENSITIVE"; break;
      case MODE_BALANCED: mode_name = "BALANCED"; break;
      case MODE_CONSERVATIVE: mode_name = "CONSERVATIVE"; break;
   }
   
   string volume_mode = UseEnhancedVolumeAnalysis ? "ENHANCED" : "CLASSIC";
   string backtest_suffix = IsBacktest() ? "-BACKTEST" : "-TEMPO-REAL";
   string license_suffix = isUniversalLicense ? "-UNIVERSAL" : "-ESPEC√çFICA";
   string tracing_mode = UseCleanerLines ? "TRA√áADO INTELIGENTE" : "QUALIDADE RSI";
   string pivot_mode = UseFlexiblePivots ? "PIV√îS FLEX√çVEIS" : "PIV√îS R√çGIDOS";
   string strict_mode = EnableStrictDivergenceCheck ? "RIGOROSO" : "NORMAL";
   IndicatorSetString(INDICATOR_SHORTNAME, "Divergence RSI PrimeBot v2.3.8" + backtest_suffix + license_suffix + " [" + mode_name + "] [VOL:" + volume_mode + " " + tracing_mode + " " + pivot_mode + " " + strict_mode + "] [EA+ANTI-LOOP]");
   
   IndicatorSetInteger(INDICATOR_LEVELS, 6);
   
   // üîß N√çVEIS CORRIGIDOS DEFINITIVAMENTE - Escala visual correta
   
   // Linha divis√≥ria principal RSI/Volume - PRATICAMENTE INVIS√çVEL
   IndicatorSetDouble(INDICATOR_LEVELVALUE, 0, DIVIDER_LINE);
   IndicatorSetInteger(INDICATOR_LEVELCOLOR, 0, clrNONE);           // ‚úÖ SEM COR = invis√≠vel
   IndicatorSetInteger(INDICATOR_LEVELSTYLE, 0, STYLE_DOT);         // ‚úÖ Pontilhado m√≠nimo
   IndicatorSetInteger(INDICATOR_LEVELWIDTH, 0, 1);                // ‚úÖ Fino
   
   // RSI 70 (Overbought) - valor exato
   IndicatorSetDouble(INDICATOR_LEVELVALUE, 1, OverboughtLevel);    // ‚úÖ Usar input (70.0)
   IndicatorSetInteger(INDICATOR_LEVELCOLOR, 1, clrRed);
   IndicatorSetInteger(INDICATOR_LEVELSTYLE, 1, STYLE_DASH);
   IndicatorSetInteger(INDICATOR_LEVELWIDTH, 1, 1);
   
   // RSI 50 (Meio) - valor exato
   IndicatorSetDouble(INDICATOR_LEVELVALUE, 2, 50.0);
   IndicatorSetInteger(INDICATOR_LEVELCOLOR, 2, clrGray);
   IndicatorSetInteger(INDICATOR_LEVELSTYLE, 2, STYLE_DOT);
   IndicatorSetInteger(INDICATOR_LEVELWIDTH, 2, 1);
   
   // üîß RSI 30 (Oversold) - CORRE√á√ÉO DEFINITIVA usando input direto
   IndicatorSetDouble(INDICATOR_LEVELVALUE, 3, OversoldLevel);      // ‚úÖ Usar input (30.0) diretamente
   IndicatorSetInteger(INDICATOR_LEVELCOLOR, 3, clrRed);
   IndicatorSetInteger(INDICATOR_LEVELSTYLE, 3, STYLE_DASH);
   IndicatorSetInteger(INDICATOR_LEVELWIDTH, 3, 1);
   
   // Volume m√°ximo (refer√™ncia) - MAIS SUTIL
   IndicatorSetDouble(INDICATOR_LEVELVALUE, 4, VOLUME_ZONE_MAX);
   IndicatorSetInteger(INDICATOR_LEVELCOLOR, 4, clrDimGray);        // ‚úÖ Cor mais suave
   IndicatorSetInteger(INDICATOR_LEVELSTYLE, 4, STYLE_DASHDOTDOT);  // ‚úÖ Estilo mais discreto
   IndicatorSetInteger(INDICATOR_LEVELWIDTH, 4, 1);
   
   // Volume meio (refer√™ncia) - MAIS SUTIL
   IndicatorSetDouble(INDICATOR_LEVELVALUE, 5, VOLUME_ZONE_MAX/2);
   IndicatorSetInteger(INDICATOR_LEVELCOLOR, 5, clrDimGray);        // ‚úÖ Cor mais suave
   IndicatorSetInteger(INDICATOR_LEVELSTYLE, 5, STYLE_DASHDOTDOT);  // ‚úÖ Estilo mais discreto
   IndicatorSetInteger(INDICATOR_LEVELWIDTH, 5, 1);
   
   IndicatorSetString(INDICATOR_LEVELTEXT, 0, "");
   IndicatorSetString(INDICATOR_LEVELTEXT, 1, "RSI " + DoubleToString(OverboughtLevel, 0) + " (Overbought)");  // ‚úÖ Texto din√¢mico
   IndicatorSetString(INDICATOR_LEVELTEXT, 2, "RSI 50 (Neutro)");
   IndicatorSetString(INDICATOR_LEVELTEXT, 3, "RSI " + DoubleToString(OversoldLevel, 0) + " (Oversold)");    // ‚úÖ Texto din√¢mico
   IndicatorSetString(INDICATOR_LEVELTEXT, 4, "Vol Max");
   IndicatorSetString(INDICATOR_LEVELTEXT, 5, "Vol M√©dio");
   
   // üî• NOVO v2.3.8: Inicializar contadores anti-loop
   lastProcessedBuyBar = -1;
   lastProcessedSellBar = -1;
   copyBufferFailures = 0;
   
   // üî• LOG √öNICO NO IN√çCIO (se habilitado)
   if(ShowModeInfo) 
   {
      Print("üî• Divergence RSI PrimeBot v2.3.8 - LINHAS PARALELAS + EA + ANTI-LOOP!");
      Print("üéØ Modo: ", mode_name, " | Volume: ", volume_mode, " | Piv√¥s: ", UseFlexiblePivots ? "FLEX√çVEIS" : "R√çGIDOS");
      Print("üî• FILTROS ATIVOS: Qualidade ", MinQualityScore, " | Dist√¢ncia ", MinDistanceBetweenPivots, " | Tempo ", MinBarsBetweenSignals);
      Print("üî• VALIDA√á√ÉO CONTEXTO: ", RequireTrendContext ? "ATIVA" : "DESATIVA", " | Linha Limpa: ", RequireCleanLine ? "ATIVA" : "DESATIVA");
      Print("üî• NOVO v2.3.8: Anti-loop + EA sincronizado + Buffers corrigidos");
      Print("üìä NOVO: Valida contexto de candles para evitar sinais inadequados");
      Print("üéØ L√ìGICA: COMPRA em contexto baixista/neutro | VENDA em contexto altista/neutro");
      Print("üîß RESULTADO: Menos sinais, mas com maior qualidade + EA funcionando + Backtest OK");
      Print("   üî• EnableSignalsForEA = ", EnableSignalsForEA ? "ATIVADO" : "DESATIVADO");
   }
   
   return INIT_SUCCEEDED;
}

//+------------------------------------------------------------------+
//| Deinitialization function AJUSTADA - LOGS M√çNIMOS               |
//+------------------------------------------------------------------+
void OnDeinit(const int reason) 
{ 
   if(RSIHandle != INVALID_HANDLE) IndicatorRelease(RSIHandle); 
   ObjectsDeleteAll(0, "RSI_Volume_Star_"); 
   ObjectsDeleteAll(0, "div_line_price_"); 
   ObjectsDeleteAll(0, "div_line_rsi_");     // üî• NOVO: Limpar linhas do RSI
   ObjectsDeleteAll(0, "VolumeDebug_");      // Limpar debug de volume
   ObjectsDeleteAll(0, "VolumeCircle_");     // üî• NOVO: Limpar bolinhas de volume
   
   // üî• LOG √öNICO NO FINAL (se habilitado)
   if(ShowDebugInfo) 
   {
      Print("üìä ESTAT√çSTICAS v2.3.8 - LINHAS PARALELAS + EA + ANTI-LOOP:");
      Print("   üéØ Diverg√™ncias: ", divergencesDetected, " | Estrelas: ", signalsConfirmed, " | Enhanced: ", enhancedVolumeUsed);
      Print("   ‚úÖ Valida√ß√£o Rigorosa: ", strictValidationPassed, " passou | ", strictValidationFailed, " falhou");
      Print("   üö´ Rejei√ß√µes: ", divergenceRejections, " diverg√™ncia | ", cleanLineRejections, " linha cortada");
      Print("   üìù Textos criados: ", volumeTextsCreated);
      Print("   üî• CopyBuffer: CORRIGIDO (n√£o trava mais)");
      Print("   üî• Anti-Loop: Buy=", lastProcessedBuyBar, " | Sell=", lastProcessedSellBar);
      Print("   üîß MELHORIA: Linhas RSI agora s√£o paralelas √†s linhas de pre√ßo + EA funcionando");
   }
}

//+------------------------------------------------------------------+
//| üî• Main calculation function RIGOROSA v2.3.8 - EA CORRIGIDO     |
//+------------------------------------------------------------------+
int OnCalculate(const int rates_total, const int prev_calculated, const datetime &time[], 
                const double &open[], const double &high[], const double &low[], 
                const double &close[], const long &tick_volume[], const long &volume[], 
                const int &spread[])
{
   if(rates_total < RSI_Period + 10) return 0;
   
   // üî• CORRE√á√ÉO v2.3.8: CopyBuffer com tratamento melhorado
   int rsi_copied = CopyBuffer(RSIHandle, 0, 0, rates_total, RawRSIBuffer);
   if(rsi_copied <= 0) 
   { 
      copyBufferFailures++; // Contar falhas para estat√≠sticas
      
      if(ShowDebugInfo && copyBufferFailures <= 3) // Limitar logs de falha
         Print("‚ö†Ô∏è CopyBuffer falhou (normal): Tentativa ", copyBufferFailures, " | Erro: ", GetLastError(), " | Retentando...");
      
      // üî• CORRE√á√ÉO CR√çTICA: Retornar 0 for√ßa o MT5 a tentar recalcular
      return 0; // ‚úÖ CORRIGIDO: N√£o trava mais!
   }
   
   if(prev_calculated == 0) 
   {
      g_max_volume = 1;
      divergencesDetected = 0;
      signalsConfirmed = 0;
      signalsFiltered = 0;
      qualityFiltered = 0;
      contextFiltered = 0;
      mixedTypeFiltered = 0;
      realDivFiltered = 0;
      cleanLineFiltered = 0;
      enhancedVolumeUsed = 0;
      volumeTextsCreated = 0; // ‚úÖ Reset contador de textos
      
      // üî• NOVO: Reset contadores de valida√ß√£o rigorosa
      strictValidationPassed = 0;
      strictValidationFailed = 0;
      cleanLineRejections = 0;
      divergenceRejections = 0;
      
      // ‚úÖ RESETAR CONTADORES DE SEQU√äNCIA
      lastBullishPivotBar = -1;
      lastBearishPivotBar = -1;
      consecutiveBullishPivots = 0;
      consecutiveBearishPivots = 0;
      
      // üî• NOVO v2.3.8: Resetar contadores anti-loop
      lastProcessedBuyBar = -1;
      lastProcessedSellBar = -1;
   }
   
   int start_calc = prev_calculated > 1 ? prev_calculated - 1 : 0;
   
   // ‚úÖ CORRE√á√ÉO: Atualizar buffers mantendo escala 0-100 para n√∫meros corretos
   for(int i = start_calc; i < rates_total; i++)
   {
      if(tick_volume[i] > g_max_volume) g_max_volume = tick_volume[i];
      
      // ‚úÖ RSI: Manter valores originais 0-100, mas posicionar na zona correta visualmente
      if(RawRSIBuffer[i] <= 30.0)
      {
         // Valores baixos (0-30) ficam comprimidos pr√≥ximo a 30
         RSIBuffer[i] = 30.0 + (RawRSIBuffer[i] / 30.0) * 5.0; // Comprime em 5 pontos
      }
      else
      {
         // Valores 30-100 mant√™m propor√ß√£o original na zona 35-100
         RSIBuffer[i] = 35.0 + ((RawRSIBuffer[i] - 30.0) / 70.0) * 65.0;
      }
      
      DividerBuffer[i] = DIVIDER_LINE;  // Linha divis√≥ria suave
      VolumeBuffer[i] = ScaleVolumeValue(tick_volume[i], g_max_volume);  // Volume na zona 0-25
      
      if(i >= Volume_Period) 
      { 
         long sum_vol = 0; 
         for(int j=0; j<Volume_Period; j++) 
            sum_vol += tick_volume[i-j]; 
         VolumeAvgBuffer[i] = ScaleVolumeValue(sum_vol/Volume_Period, g_max_volume); 
      }
   }
   
   int limit = prev_calculated == 0 ? RSI_Period + DivergenceLookback : prev_calculated - 1;
   
   // ‚úÖ CORRE√á√ÉO TEMPO REAL: Determina at√© onde processar
   int max_process = rates_total - (IsBacktest() ? 1 : 0);  // Backtest: rates_total-1, Tempo Real: rates_total
   
   // üî• LOOP PRINCIPAL v2.3.8 - COM ANTI-LOOP + TRA√áADO CORRETO
   for(int i = limit; i < max_process; i++)
   {
      // Limpar buffers visuais
      BuyBuffer[i] = 0; 
      SellBuffer[i] = 0;
      
      if(i < RSI_Period || RawRSIBuffer[i] == 0) continue;
      
      // ===== üî• DETEC√á√ÉO DE COMPRA RIGOROSA COM ANTI-LOOP - FUNDOS‚ÜîFUNDOS =====
      int buy_pivot = CheckClassicDivergence(low, RawRSIBuffer, tick_volume, open, close, i, true);
      if(buy_pivot > 0)
      {
         // üî• NOVO v2.3.8: Verificar se j√° foi processado (anti-loop)
         if(!IsBarAlreadyProcessed(i, true))
         {
            divergencesDetected++;
            BuyBuffer[i] = RSIBuffer[i] - 3.0;  // üî• SEMPRE marca diverg√™ncia detectada
            
            // üî• BUSCA MELHORADA: FUNDOS RSI pr√≥ximos √†s M√çNIMAS de pre√ßo
            RSIPivots rsi_pivots = FindRSIPivotsStrict(RawRSIBuffer, buy_pivot, i, true, 
                                                      low[buy_pivot], low[i]);
            
            // üî• SEMPRE USAR OS PIV√îS ENCONTRADOS (fun√ß√£o melhorada sempre retorna v√°lido)
            if(rsi_pivots.valid)
            {
               // ‚úÖ TRA√áADO RSI: Conecta FUNDOS RSI reais (sem cortar outros fundos)
               CreateRSILine(time[rsi_pivots.rsi_pivot_past], RSIBuffer[rsi_pivots.rsi_pivot_past], 
                            time[rsi_pivots.rsi_pivot_current], RSIBuffer[rsi_pivots.rsi_pivot_current], true);
               
               // ‚úÖ TRA√áADO PRE√áO: Conecta M√çNIMAS de pre√ßo (low‚Üîlow)
               if(ShowDivergenceLines)
                  CreatePriceLine(time[buy_pivot], low[buy_pivot], time[i], low[i], true);
               
               // üî• LOG de confirma√ß√£o rigorosa
               if(ShowDivergenceValidation)
               {
                  PrintControlledLog("COMPRA V√ÅLIDA - Pre√ßo: " + DoubleToString(low[buy_pivot], 5) + "‚Üí" + DoubleToString(low[i], 5) + 
                                   " (Œî" + DoubleToString(((low[i]-low[buy_pivot])/low[buy_pivot])*100, 2) + "%) | " +
                                   "RSI: " + DoubleToString(RawRSIBuffer[rsi_pivots.rsi_pivot_past], 1) + "‚Üí" + 
                                   DoubleToString(RawRSIBuffer[rsi_pivots.rsi_pivot_current], 1) + 
                                   " (Œî+" + DoubleToString(RawRSIBuffer[rsi_pivots.rsi_pivot_current] - RawRSIBuffer[rsi_pivots.rsi_pivot_past], 1) + ")");
               }
            }
            else
            {
               if(ShowDivergenceValidation)
                  PrintControlledLog("COMPRA REJEITADA - Tra√ßado inv√°lido ou n√£o √© diverg√™ncia real");
               continue; // Pular para pr√≥xima itera√ß√£o
            }
            
            // üî• SEMPRE MOSTRAR % VOLUME ENHANCED PARA AN√ÅLISE VISUAL
            if(ShowVolumeDebugOnChart || ShowDetailedVolumeInfo)
            {
               // Volume original - SEMPRE mostrar
               double volumeChangePercent = GetVolumeChangePercent(tick_volume, buy_pivot, i);
               bool volumeOK = volumeChangePercent >= Volume_Divergence_Min;
               string volumeText = (volumeOK ? "‚úì" : "‚úó") + "Vol:" + DoubleToString(volumeChangePercent, 1) + "%";
               CreateVolumeDebugText(time[i], close[i] - SymbolInfoDouble(_Symbol, SYMBOL_POINT) * 30, volumeText, volumeOK ? clrYellow : clrGray);
               
               if(ShowDetailedVolumeInfo)
               {
                  // Volume direcionais - SEMPRE mostrar
                  bool candleOK = CheckCandleDirectionVolume(open, close, tick_volume, i, true);
                  long targetVolume = 0, totalVol = 0;
                  for(int k = 0; k < 5 && (i-k) >= 0; k++) {
                     totalVol += tick_volume[i-k];
                     if(close[i-k] > open[i-k]) targetVolume += tick_volume[i-k];
                  }
                  double candlePercentage = totalVol > 0 ? ((double)targetVolume / totalVol * 100.0) : 0;
                  string candleString = (candleOK ? "‚úì" : "‚úó") + "C:" + DoubleToString(candlePercentage, 0) + "%";
                  CreateVolumeDebugText(time[i], high[i] + SymbolInfoDouble(_Symbol, SYMBOL_POINT) * 80, candleString, candleOK ? clrLimeGreen : clrGray);
                  
                  // Fluxo institucional - SEMPRE mostrar
                  bool institutionalOK = CheckInstitutionalVolumeFlow(low, tick_volume, buy_pivot, i, true);
                  string institutionalText = (institutionalOK ? "‚úì" : "‚úó") + "I:inst";
                  CreateVolumeDebugText(time[i], low[i] - SymbolInfoDouble(_Symbol, SYMBOL_POINT) * 80, institutionalText, institutionalOK ? clrGold : clrGray);
                  
                  // Enhanced final - SEMPRE mostrar
                  int criteriaCount = (volumeOK ? 1 : 0) + (candleOK ? 1 : 0) + (institutionalOK ? 1 : 0);
                  string enhancedString = "E:" + (string)criteriaCount + "/3";
                  CreateVolumeDebugText(time[i], close[i] + SymbolInfoDouble(_Symbol, SYMBOL_POINT) * 50, enhancedString, clrLimeGreen);
               }
            }
            
            // ===== üî• ESTRELA DOURADA COM VALIDA√á√ÉO DE CONTEXTO + ANTI-LOOP =====
            bool volumeEnhancedOK = CheckVolumeConfirmationEnhanced(true, open, close, low, tick_volume, buy_pivot, i);
            bool candleContextOK = IsValidCandleContext(open, close, high, low, i, true);
            bool timingOK = IsValidConfirmationTiming(open, close, high, low, i, true);
            bool distanceOK = IsValidSignalDistance(i, lastBuySignalBar, rates_total, true);
            
            // üî• NOVO v2.3.8: Usar fun√ß√£o unificada se confirmado
            if(volumeEnhancedOK && candleContextOK && timingOK && distanceOK)
            {
               ProcessConfirmedSignal(i, true, time, high, low, GetVolumeChangePercent(tick_volume, buy_pivot, i));
               
               // üî• FOR√áAR CRIA√á√ÉO DOS TEXTOS DE % AP√ìS CONFIRMA√á√ÉO DA ESTRELA - S√ì SE HABILITADO
               if(ShowVolumeDebugOnChart || (ShowDetailedVolumeInfo && ShowOnlyConfirmedStars))
               {
                  CreateVolumeDebugText(time[i], high[i] + SymbolInfoDouble(_Symbol, SYMBOL_POINT) * 120, 
                                      "‚≠êCOMPRA CONFIRMADA‚≠ê", clrGold);
               }
               
               // üî• CRIAR BOLINHA NO VOLUME QUANDO ENHANCED CONFIRMA
               if(ShowVolumeCircles)
               {
                  CreateVolumeCircle(time[i], VolumeBuffer[i], true);
               }
            }
            else
            {
               if(ShowDebugInfo)
                  PrintControlledLog("COMPRA v2.3.8 N√ÉO confirmada | Vol:" + (volumeEnhancedOK ? "OK" : "NO") + 
                                   " | Candle:" + (candleContextOK ? "OK" : "NO") + " | Timing:" + (timingOK ? "OK" : "NO") + 
                                   " | Dist:" + (distanceOK ? "OK" : "NO"));
            }
         }
      }
      
      // ===== üî• DETEC√á√ÉO DE VENDA RIGOROSA COM ANTI-LOOP - TOPOS‚ÜîTOPOS =====
      int sell_pivot = CheckClassicDivergence(high, RawRSIBuffer, tick_volume, open, close, i, false);
      if(sell_pivot > 0)
      {
         // üî• NOVO v2.3.8: Verificar se j√° foi processado (anti-loop)
         if(!IsBarAlreadyProcessed(i, false))
         {
            divergencesDetected++;
            SellBuffer[i] = RSIBuffer[i] + 3.0;  // üî• SEMPRE marca diverg√™ncia detectada
            
            // üî• BUSCA MELHORADA: TOPOS RSI pr√≥ximos √†s M√ÅXIMAS de pre√ßo
            RSIPivots rsi_pivots = FindRSIPivotsStrict(RawRSIBuffer, sell_pivot, i, false, 
                                                      high[sell_pivot], high[i]);
            
            // üî• SEMPRE USAR OS PIV√îS ENCONTRADOS (fun√ß√£o melhorada sempre retorna v√°lido)
            if(rsi_pivots.valid)
            {
               // ‚úÖ TRA√áADO RSI: Conecta TOPOS RSI reais (sem cortar outros topos)
               CreateRSILine(time[rsi_pivots.rsi_pivot_past], RSIBuffer[rsi_pivots.rsi_pivot_past], 
                            time[rsi_pivots.rsi_pivot_current], RSIBuffer[rsi_pivots.rsi_pivot_current], false);
               
               // ‚úÖ TRA√áADO PRE√áO: Conecta M√ÅXIMAS de pre√ßo (high‚Üîhigh)
               if(ShowDivergenceLines)
                  CreatePriceLine(time[sell_pivot], high[sell_pivot], time[i], high[i], false);
               
               // üî• LOG de confirma√ß√£o rigorosa
               if(ShowDivergenceValidation)
               {
                  PrintControlledLog("VENDA V√ÅLIDA - Pre√ßo: " + DoubleToString(high[sell_pivot], 5) + "‚Üí" + DoubleToString(high[i], 5) + 
                                   " (Œî+" + DoubleToString(((high[i]-high[sell_pivot])/high[sell_pivot])*100, 2) + "%) | " +
                                   "RSI: " + DoubleToString(RawRSIBuffer[rsi_pivots.rsi_pivot_past], 1) + "‚Üí" + 
                                   DoubleToString(RawRSIBuffer[rsi_pivots.rsi_pivot_current], 1) + 
                                   " (Œî-" + DoubleToString(RawRSIBuffer[rsi_pivots.rsi_pivot_past] - RawRSIBuffer[rsi_pivots.rsi_pivot_current], 1) + ")");
               }
            }
            else
            {
               if(ShowDivergenceValidation)
                  PrintControlledLog("VENDA REJEITADA - Tra√ßado inv√°lido ou n√£o √© diverg√™ncia real");
               continue; // Pular para pr√≥xima itera√ß√£o
            }
            
            // üî• SEMPRE MOSTRAR % VOLUME ENHANCED PARA AN√ÅLISE VISUAL
            if(ShowVolumeDebugOnChart || ShowDetailedVolumeInfo)
            {
               // Volume original - SEMPRE mostrar
               double volumeChangePercent = GetVolumeChangePercent(tick_volume, sell_pivot, i);
               bool volumeOK = volumeChangePercent >= Volume_Divergence_Min;
               string volumeText = (volumeOK ? "‚úì" : "‚úó") + "Vol:" + DoubleToString(volumeChangePercent, 1) + "%";
               CreateVolumeDebugText(time[i], close[i] - SymbolInfoDouble(_Symbol, SYMBOL_POINT) * 30, volumeText, volumeOK ? clrYellow : clrGray);
               
               if(ShowDetailedVolumeInfo)
               {
                  // Volume direcionais - SEMPRE mostrar
                  bool candleOK = CheckCandleDirectionVolume(open, close, tick_volume, i, false);
                  long targetVolume = 0, totalVol = 0;
                  for(int k = 0; k < 5 && (i-k) >= 0; k++) {
                     totalVol += tick_volume[i-k];
                     if(close[i-k] < open[i-k]) targetVolume += tick_volume[i-k];
                  }
                  double candlePercentage = totalVol > 0 ? ((double)targetVolume / totalVol * 100.0) : 0;
                  string candleString = (candleOK ? "‚úì" : "‚úó") + "V:" + DoubleToString(candlePercentage, 0) + "%";
                  CreateVolumeDebugText(time[i], high[i] + SymbolInfoDouble(_Symbol, SYMBOL_POINT) * 80, candleString, candleOK ? clrRed : clrGray);
                  
                  // Fluxo institucional - SEMPRE mostrar
                  bool institutionalOK = CheckInstitutionalVolumeFlow(high, tick_volume, sell_pivot, i, false);
                  string institutionalText = (institutionalOK ? "‚úì" : "‚úó") + "i:inst";
                  CreateVolumeDebugText(time[i], low[i] - SymbolInfoDouble(_Symbol, SYMBOL_POINT) * 80, institutionalText, institutionalOK ? clrMagenta : clrGray);
                  
                  // Enhanced final - SEMPRE mostrar
                  int criteriaCount = (volumeOK ? 1 : 0) + (candleOK ? 1 : 0) + (institutionalOK ? 1 : 0);
                  string enhancedString = "E:" + (string)criteriaCount + "/3";
                  CreateVolumeDebugText(time[i], close[i] + SymbolInfoDouble(_Symbol, SYMBOL_POINT) * 50, enhancedString, clrRed);
               }
            }
            
            // ===== üî• ESTRELA MAGENTA COM VALIDA√á√ÉO DE CONTEXTO + ANTI-LOOP =====
            bool volumeEnhancedOK = CheckVolumeConfirmationEnhanced(false, open, close, high, tick_volume, sell_pivot, i);
            bool candleContextOK = IsValidCandleContext(open, close, high, low, i, false);
            bool timingOK = IsValidConfirmationTiming(open, close, high, low, i, false);
            bool distanceOK = IsValidSignalDistance(i, lastSellSignalBar, rates_total, false);
            
            // üî• NOVO v2.3.8: Usar fun√ß√£o unificada se confirmado
            if(volumeEnhancedOK && candleContextOK && timingOK && distanceOK)
            {
               ProcessConfirmedSignal(i, false, time, high, low, GetVolumeChangePercent(tick_volume, sell_pivot, i));
               
               // üî• FOR√áAR CRIA√á√ÉO DOS TEXTOS DE % AP√ìS CONFIRMA√á√ÉO DA ESTRELA - S√ì SE HABILITADO
               if(ShowVolumeDebugOnChart || (ShowDetailedVolumeInfo && ShowOnlyConfirmedStars))
               {
                  CreateVolumeDebugText(time[i], high[i] + SymbolInfoDouble(_Symbol, SYMBOL_POINT) * 120, 
                                      "‚≠êVENDA CONFIRMADA‚≠ê", clrMagenta);
               }
               
               // üî• CRIAR BOLINHA NO VOLUME QUANDO ENHANCED CONFIRMA
               if(ShowVolumeCircles)
               {
                  CreateVolumeCircle(time[i], VolumeBuffer[i], false);
               }
            }
            else
            {
               if(ShowDebugInfo)
                  PrintControlledLog("VENDA v2.3.8 N√ÉO confirmada | Vol:" + (volumeEnhancedOK ? "OK" : "NO") + 
                                   " | Candle:" + (candleContextOK ? "OK" : "NO") + " | Timing:" + (timingOK ? "OK" : "NO") + 
                                   " | Dist:" + (distanceOK ? "OK" : "NO"));
            }
         }
      }
   }
   
   // üî• LOG √öNICO NO FINAL (apenas primeira execu√ß√£o)
   if(ShowDebugInfo && prev_calculated == 0)
   {
      Print("‚úÖ HIST√ìRICO v2.3.8 - LINHAS PARALELAS + EA + ANTI-LOOP: ", rates_total, " barras processadas");
      Print("   üéØ Diverg√™ncias: ", divergencesDetected, " | Estrelas: ", signalsConfirmed, " | Enhanced: ", enhancedVolumeUsed);
      Print("   ‚úÖ Valida√ß√£o: ", strictValidationPassed, " passou | ", strictValidationFailed, " falhou");
      Print("   üö´ Rejei√ß√µes: ", divergenceRejections, " diverg√™ncia | ", cleanLineRejections, " linha cortada");
      Print("   üìù Textos: ", MaxVolumeTextsOnChart, " limite | ", volumeTextsCreated, " criados");
      Print("   üî• CopyBuffer: CORRIGIDO (", copyBufferFailures, " falhas tratadas)");
      Print("   üî• Sistema Anti-Loop: ATIVO (Buy=", lastProcessedBuyBar, " | Sell=", lastProcessedSellBar, ")");
      Print("   üî• EnableSignalsForEA: ", EnableSignalsForEA ? "ATIVADO" : "DESATIVADO");
      Print("   üîß RESULTADO: Linhas RSI e Pre√ßo paralelas + EA funcionando + Backtest OK + Tempo Real OK");
   }
   
   return rates_total; // ‚úÖ SEMPRE retorna rates_total quando bem-sucedido
}
//+------------------------------------------------------------------+
