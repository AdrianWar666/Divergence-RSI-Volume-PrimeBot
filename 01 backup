//+------------------------------------------------------------------+
//|               RSI Volume FUSION v2.1.5 - PREMIUM EDITION       |
//|  ULTRA RESPONSIVO + SEPARA√á√ÉO VISUAL + FILTROS INTELIGENTES     |
//|                     Copyright PrimeBot 2025                      |
//|                  https://www.primebotportfolio.com.br/           |
//|------------------------------------------------------------------|
//| v2.1.5 - PREMIUM EDITION - MELHORIAS IMPLEMENTADAS:            |
//| üîß SEPARA√á√ÉO VISUAL: RSI (30-100) + Volume (0-30)              |
//| üîß CONTROLE SEQU√äNCIA: Evita sinais ap√≥s fundos consecutivos    |
//| üîß INCLINA√á√ÉO M√çNIMA: Filtra linhas quase retas                 |
//| üîß CONTEXTO TEND√äNCIA: Diverg√™ncia no contexto correto          |
//| üîß VOLUME VISUAL: M√©todo comparativo melhorado                  |
//| üîß TEMPO REAL: M√°xima responsividade sem repintar               |
//| ‚úÖ RESULTADO: Evita Print 1, detecta Print 3, qualidade++      |
//| üîß CORRE√á√ÉO: Escala √† direita correta + divis√≥ria invis√≠vel     |
//| üî• CORRE√á√ÉO v2.1.5-FIX: CopyBuffer corrigido - Sinais ao vivo!  |
//+------------------------------------------------------------------+
#property copyright "Copyright PrimeBot 2025"
#property link      "https://www.primebotportfolio.com.br/"
#property version   "2.15"
#property description "RSI VOLUME FUSION v2.1.5 - PREMIUM: SEPARA√á√ÉO VISUAL + FILTROS INTELIGENTES + TEMPO REAL CORRIGIDO"
#property indicator_separate_window
#property indicator_buffers 14
#property indicator_plots   14
#property indicator_minimum 0
#property indicator_maximum 100

//--- Plots
#property indicator_label1  "RSI"
#property indicator_type1   DRAW_LINE
#property indicator_color1  clrDodgerBlue
#property indicator_style1  STYLE_SOLID
#property indicator_width1  2
#property indicator_label2  "Buy Signal"
#property indicator_type2   DRAW_ARROW
#property indicator_color2  clrPaleGreen
#property indicator_style2  STYLE_SOLID
#property indicator_width2  2
#property indicator_label3  "Sell Signal"
#property indicator_type3   DRAW_ARROW
#property indicator_color3  clrLightSalmon
#property indicator_style3  STYLE_SOLID
#property indicator_width3  2
#property indicator_label4  "RSI Divergence Line"
#property indicator_type4   DRAW_LINE
#property indicator_color4  clrYellow
#property indicator_style4  STYLE_SOLID
#property indicator_width4  3
#property indicator_label5  "Volume"
#property indicator_type5   DRAW_HISTOGRAM
#property indicator_color5  clrGray
#property indicator_style5  STYLE_SOLID
#property indicator_width5  2
#property indicator_label6  "Volume Average"
#property indicator_type6   DRAW_LINE
#property indicator_color6  clrYellow
#property indicator_style6  STYLE_SOLID
#property indicator_width6  1
#property indicator_label7  "Volume Buy Confirm"
#property indicator_type7   DRAW_ARROW
#property indicator_color7  clrGold
#property indicator_style7  STYLE_SOLID
#property indicator_width7  6
#property indicator_label8  "Volume Sell Confirm"
#property indicator_type8   DRAW_ARROW
#property indicator_color8  clrMagenta
#property indicator_style8  STYLE_SOLID
#property indicator_width8  6
#property indicator_label9  "Divider Line"
#property indicator_type9   DRAW_LINE
#property indicator_color9  clrDimGray
#property indicator_style9  STYLE_DOT
#property indicator_width9  1
#property indicator_label10 "Buy Signal Confirmed"
#property indicator_type10  DRAW_NONE
#property indicator_label11 "Sell Signal Confirmed"
#property indicator_type11  DRAW_NONE
#property indicator_label12 "Raw RSI Data"
#property indicator_type12  DRAW_NONE
#property indicator_label13 "Buy Circle Backtest"
#property indicator_type13  DRAW_ARROW
#property indicator_color13 clrGold
#property indicator_width13 5
#property indicator_label14 "Sell Circle Backtest"
#property indicator_type14  DRAW_ARROW
#property indicator_color14 clrMagenta
#property indicator_width14 5

// ‚úÖ ESCALAS CORRIGIDAS - Mant√©m escala 0-100 mas separa visualmente
#define RSI_ZONE_MIN 30.0       // RSI regi√£o visual m√≠nima
#define RSI_ZONE_MAX 100.0      // RSI regi√£o visual m√°xima  
#define VOLUME_ZONE_MIN 0.0     // Volume regi√£o visual m√≠nima
#define VOLUME_ZONE_MAX 25.0    // Volume regi√£o visual m√°xima
#define DIVIDER_LINE 28.0       // Linha divis√≥ria entre Volume e RSI
#define SYMBOL_STAR 108

//+------------------------------------------------------------------+
//| Enum para modos de diverg√™ncia                                  |
//+------------------------------------------------------------------+
enum ENUM_DIVERGENCE_MODE
{
   MODE_SENSITIVE = 0,      // Atual - Muitos sinais (para backtest)
   MODE_BALANCED = 1,       // Melhorado - Recomendado
   MODE_CONSERVATIVE = 2    // S√≥ diverg√™ncias √≥bvias
};

//+------------------------------------------------------------------+
//| Inputs                                                           |
//+------------------------------------------------------------------+
input int RSI_Period = 14;
input ENUM_APPLIED_PRICE RSI_Applied = PRICE_CLOSE;
input bool OnlyExtremeLevels = false;
input double OverboughtLevel = 70.0;
input double OversoldLevel = 30.0;
input int MinBarsBetweenSignals = 1;              // ‚úÖ REDUZIDO: Mais responsivo

input int Volume_Period = 14;                    // Per√≠odo para m√©dia de volume - OTIMIZADO
input double Volume_Divergence_Min = 3.0;        // Mudan√ßa m√≠nima volume % - RELAXADO
input double Min_Volume_Factor = 0.5;

input ENUM_DIVERGENCE_MODE DivergenceMode = MODE_BALANCED;       // ‚úÖ EQUILIBRADO
input int    DivergenceLookback = 12;        // ‚úÖ REDUZIDO: Mais responsivo
input int    PivotStrength = 1;              // ‚úÖ M√çNIMO: M√°xima sensibilidade
input double MinRSIDifference = 1.5;         // ‚úÖ RELAXADO: Mais sinais
input double MinPriceDifference = 0.03;      // ‚úÖ RELAXADO: Mais sinais
input bool   ShowModeInfo = true;            // Mostrar info do modo

input group "=== üî• Valida√ß√µes v2.1.5 TEMPO REAL ==="
input double MinPivotAmplitude = 0.3;        // ‚úÖ MUITO RELAXADO: Detecta mais diverg√™ncias
input bool   RequireTrendContext = false;    // ‚úÖ DESATIVADO: Mais sinais
input double MinQualityScore = 10.0;         // ‚úÖ MUITO RELAXADO: Score m√≠nimo baixo
input int    MinDistanceBetweenPivots = 1;   // ‚úÖ M√çNIMO: Piv√¥s mais pr√≥ximos
input bool   RequireCleanLine = false;       // ‚úÖ DESATIVADO: Sem filtro de obstru√ß√µes

input group "=== üîß Anti Look-Ahead Settings ==="
input bool EnableAntiLookAhead = false;          // ‚úÖ DESATIVADO: Comportamento consistente sempre
input int PivotConfirmationBars = 0;             // ‚úÖ SEM DELAY: Resposta imediata

input group "=== Visual Settings ==="
input bool RequireVolumeConfirmation = false;    // ‚úÖ SEMPRE VERIFICA VOLUME NAS ESTRELAS (movido)
input bool ShowStarsOnChart = true;              // Mostrar estrelas no gr√°fico (movido)
input bool EnableSignalsForEA = true;            // Liga sinais para EA (movido)
input color DividerColor = clrNONE;  // ‚úÖ Sem cor = invis√≠vel
input bool ShowDivergenceLines = true;

input group "=== Debug v2.1.4 ==="
input bool ShowDebugInfo = false;
input bool ShowVolumeDebugOnChart = true;       // Mostrar % volume no gr√°fico

//+------------------------------------------------------------------+
//| Buffers e Vari√°veis                                             |
//+------------------------------------------------------------------+
double RSIBuffer[], BuyBuffer[], SellBuffer[], RSILineBuffer[], VolumeBuffer[];
double VolumeAvgBuffer[], VolumeBuyConfirmBuffer[], VolumeSellConfirmBuffer[], DividerBuffer[];
double BuySignalConfirmedBuffer[], SellSignalConfirmedBuffer[], RawRSIBuffer[];
double BuyStarBacktestBuffer[], SellStarBacktestBuffer[];
int starCounter = 0;
int lineCounter = 0;
int lastBuySignalBar = -1;
int lastSellSignalBar = -1;
int RSIHandle;
long g_max_volume = 1;

// Debug contadores v2.1.5
int divergencesDetected = 0;
int signalsConfirmed = 0;
int signalsFiltered = 0;
int qualityFiltered = 0;
int contextFiltered = 0;
int mixedTypeFiltered = 0;
int realDivFiltered = 0;
int cleanLineFiltered = 0;  // NOVO: Contador para linhas n√£o limpas

// ‚úÖ NOVO: Controle de sequ√™ncia RSI (evitar sinais ap√≥s v√°rios fundos consecutivos)
int lastBullishPivotBar = -1;
int lastBearishPivotBar = -1;
int consecutiveBullishPivots = 0;
int consecutiveBearishPivots = 0;

// üî• NOVO v2.1.5-FIX: Controle para falhas de CopyBuffer
int copyBufferFailures = 0;
int maxCopyBufferRetries = 3;

string licenseAccount = "467151"; // Edite aqui o n√∫mero da conta
datetime licenseExpiration = D'2025.12.31 17:55:59'; // Edite aqui a data de expira√ß√£o (formato: YYYY.MM.DD HH:MM:SS)

//+------------------------------------------------------------------+
//| Fun√ß√µes de escalonamento CORRIGIDAS - Escala 0-100 Original     |
//+------------------------------------------------------------------+
double ScaleRSIValue(double rsiValue) 
{ 
   // ‚úÖ MANT√âM ESCALA ORIGINAL 0-100, mas posiciona na zona RSI (30-100)
   return RSI_ZONE_MIN + (rsiValue / 100.0) * (RSI_ZONE_MAX - RSI_ZONE_MIN);
}

double ScaleVolumeValue(double volumeValue, long maxVolume) 
{ 
   if(maxVolume <= 0) return VOLUME_ZONE_MIN; 
   
   // ‚úÖ Volume normalizado para zona 0-25
   double normalizedVolume = (double)volumeValue / (double)maxVolume;
   if(normalizedVolume > 1.0) normalizedVolume = 1.0;
   
   return VOLUME_ZONE_MIN + (normalizedVolume * (VOLUME_ZONE_MAX - VOLUME_ZONE_MIN)); 
}

//+------------------------------------------------------------------+
//| Valida√ß√£o de linha de diverg√™ncia limpa (sem obstru√ß√µes)        |
//+------------------------------------------------------------------+
bool IsCleanDivergenceLine(const double &price[], const double &rsi[], int start_bar, int end_bar, bool is_bullish)
{
   if(start_bar == end_bar) return false;
   if(start_bar > end_bar) { int temp = start_bar; start_bar = end_bar; end_bar = temp; } // Garantir ordem
   
   double start_price = price[start_bar];
   double end_price = price[end_bar];
   double start_rsi = rsi[start_bar];
   double end_rsi = rsi[end_bar];
   
   // Toler√¢ncia para "linha limpa" (2% do movimento do pre√ßo)
   double price_tolerance = MathAbs(end_price - start_price) * 0.02;
   double rsi_tolerance = MathAbs(end_rsi - start_rsi) * 0.1;
   
   for(int i = start_bar + 1; i < end_bar; i++)
   {
      if(is_bullish)
      {
         // Diverg√™ncia Bullish: pre√ßo faz fundos menores, RSI fundos maiores
         // Verificar se h√° fundos intermedi√°rios que "cortam" a linha
         
         // 1. Verificar linha de pre√ßo (n√£o deve ter fundos muito abaixo)
         double min_price_allowed = MathMin(start_price, end_price) - price_tolerance;
         if(price[i] < min_price_allowed)
         {
            if(ShowDebugInfo)
               Print("‚ùå LINHA N√ÉO LIMPA (Bullish): Fundo intermedi√°rio na barra ", i, " | Pre√ßo: ", price[i], " < M√≠n permitido: ", min_price_allowed);
            return false;
         }
         
         // 2. Verificar se h√° piv√¥s RSI que quebram a l√≥gica
         bool isPivotRsi = IsValidPivot(rsi, i, false, 1); // Piv√¥ simples
         if(isPivotRsi && rsi[i] < MathMin(start_rsi, end_rsi) - rsi_tolerance)
         {
            if(ShowDebugInfo)
               Print("‚ùå LINHA N√ÉO LIMPA (Bullish): Piv√¥ RSI intermedi√°rio quebra l√≥gica na barra ", i, " | RSI: ", rsi[i]);
            return false;
         }
      }
      else
      {
         // Diverg√™ncia Bearish: pre√ßo faz topos maiores, RSI topos menores
         // Verificar se h√° topos intermedi√°rios que "cortam" a linha
         
         // 1. Verificar linha de pre√ßo (n√£o deve ter topos muito acima)
         double max_price_allowed = MathMax(start_price, end_price) + price_tolerance;
         if(price[i] > max_price_allowed)
         {
            if(ShowDebugInfo)
               Print("‚ùå LINHA N√ÉO LIMPA (Bearish): Topo intermedi√°rio na barra ", i, " | Pre√ßo: ", price[i], " > M√°x permitido: ", max_price_allowed);
            return false;
         }
         
         // 2. Verificar se h√° piv√¥s RSI que quebram a l√≥gica
         bool isPivotRsi = IsValidPivot(rsi, i, true, 1); // Piv√¥ simples
         if(isPivotRsi && rsi[i] > MathMax(start_rsi, end_rsi) + rsi_tolerance)
         {
            if(ShowDebugInfo)
               Print("‚ùå LINHA N√ÉO LIMPA (Bearish): Piv√¥ RSI intermedi√°rio quebra l√≥gica na barra ", i, " | RSI: ", rsi[i]);
            return false;
         }
      }
   }
   
   if(ShowDebugInfo)
      Print("‚úÖ LINHA LIMPA (", is_bullish ? "Bullish" : "Bearish", "): Sem obstru√ß√µes entre barras ", start_bar, " e ", end_bar);
   
   return true;
}

//+------------------------------------------------------------------+
//| Detectar se est√° em backtest                                    |
//+------------------------------------------------------------------+
bool IsBacktest()
{
   return (MQLInfoInteger(MQL_TESTER) || 
           MQLInfoInteger(MQL_OPTIMIZATION) ||
           MQLInfoInteger(MQL_VISUAL_MODE));
}

//+------------------------------------------------------------------+
//| Fun√ß√£o de detec√ß√£o de piv√¥s ANTI LOOK-AHEAD                     |
//+------------------------------------------------------------------+
bool IsValidPivotAntiLookAhead(const double &data[], int position, bool isHigh, int strength, int current_bar)
{
   // üî• S√ì ATIVA SE: EnableAntiLookAhead = true E est√° em backtest
   bool useAntiLookAhead = EnableAntiLookAhead && IsBacktest();
   
   if(position < strength || position >= ArraySize(data)) return false;
   
   // üî• REGRA PRINCIPAL: S√≥ confirma piv√¥ ap√≥s X barras (S√ì NO BACKTEST)
   if(useAntiLookAhead && (current_bar - position) < PivotConfirmationBars) 
      return false;
   
   // Verificar piv√¥
   for(int i = 1; i <= strength; i++)
   {
      if(isHigh)
      {
         // ‚úÖ S√ì COMPARA COM PASSADO
         if(data[position] <= data[position - i])
            return false;
            
         // üî• Anti Look-Ahead S√ì NO BACKTEST
         if(useAntiLookAhead)
         {
            // S√≥ verifica dados "futuros" se j√° foram confirmados
            int check_bar = position + i;
            if(check_bar <= (current_bar - PivotConfirmationBars))
            {
               if(data[position] <= data[check_bar])
                  return false;
            }
            // Se n√£o passou tempo de confirma√ß√£o, ignora dados futuros
         }
         else
         {
            // TEMPO REAL: L√≥gica original (como estava funcionando)
            if(position + i < ArraySize(data) && data[position] <= data[position + i])
               return false;
         }
      }
      else
      {
         // ‚úÖ S√ì COMPARA COM PASSADO  
         if(data[position] >= data[position - i])
            return false;
            
         // üî• Anti Look-Ahead S√ì NO BACKTEST
         if(useAntiLookAhead)
         {
            // S√≥ verifica dados "futuros" se j√° foram confirmados
            int check_bar = position + i;
            if(check_bar <= (current_bar - PivotConfirmationBars))
            {
               if(data[position] >= data[check_bar])
                  return false;
            }
            // Se n√£o passou tempo de confirma√ß√£o, ignora dados futuros
         }
         else
         {
            // TEMPO REAL: L√≥gica original (como estava funcionando)
            if(position + i < ArraySize(data) && data[position] >= data[position + i])
               return false;
         }
      }
   }
   return true;
}

//+------------------------------------------------------------------+
//| Fun√ß√£o de detec√ß√£o de piv√¥s ORIGINAL - TEMPO REAL MELHORADA     |
//+------------------------------------------------------------------+
bool IsValidPivot(const double &data[], int position, bool isHigh, int strength)
{
   // ‚úÖ TEMPO REAL MELHORADO: Permite detec√ß√£o mais flex√≠vel na barra atual
   int array_size = ArraySize(data);
   if(array_size <= 0) return false;
   
   // üî• CORRE√á√ÉO TEMPO REAL: Mais flex√≠vel para barra atual
   int max_allowed;
   if(IsBacktest())
   {
      max_allowed = array_size - strength; // Backtest: conservador
   }
   else
   {
      // ‚úÖ TEMPO REAL: Permite at√© barra atual (mais responsivo)
      max_allowed = array_size;
   }
   
   if(position < strength || position >= max_allowed) return false;
   
   for(int i = 1; i <= strength; i++)
   {
      if(isHigh)
      {
         // Verifica passado
         if(data[position] <= data[position - i]) return false;
         
         // üî• VERIFICA FUTURO S√ì SE DISPON√çVEL (mais seguro)
         if(position + i < array_size)
         {
            if(data[position] <= data[position + i])
               return false;
         }
         // ‚úÖ SE N√ÉO H√Å DADOS FUTUROS, ACEITA (tempo real)
      }
      else
      {
         // Verifica passado  
         if(data[position] >= data[position - i]) return false;
         
         // üî• VERIFICA FUTURO S√ì SE DISPON√çVEL (mais seguro)
         if(position + i < array_size)
         {
            if(data[position] >= data[position + i])
               return false;
         }
         // ‚úÖ SE N√ÉO H√Å DADOS FUTUROS, ACEITA (tempo real)
      }
   }
   return true;
}

//+------------------------------------------------------------------+
//| Valida√ß√£o de amplitude do piv√¥ ANTI LOOK-AHEAD                  |
//+------------------------------------------------------------------+
bool IsStrongPivotAntiLookAhead(const double &data[], int position, bool isHigh, int strength, double min_amplitude, int current_bar)
{
   if(!IsValidPivotAntiLookAhead(data, position, isHigh, strength, current_bar)) return false;
   
   // üî• S√ì ATIVA SE: EnableAntiLookAhead = true E est√° em backtest
   bool useAntiLookAhead = EnableAntiLookAhead && IsBacktest();
   
   double amplitude = 0;
   for(int i = 1; i <= strength; i++)
   {
      if(isHigh)
      {
         if(useAntiLookAhead)
         {
            // BACKTEST: Anti Look-Ahead
            amplitude = MathMax(amplitude, data[position] - MathMin(data[position-i], 
                              (position+i >= current_bar) ? data[position-i] : data[position+i]));
         }
         else
         {
            // TEMPO REAL: L√≥gica original
            amplitude = MathMax(amplitude, data[position] - MathMin(data[position-i], data[position+i]));
         }
      }
      else
      {
         if(useAntiLookAhead)
         {
            // BACKTEST: Anti Look-Ahead
            amplitude = MathMax(amplitude, MathMax(data[position-i], 
                              (position+i >= current_bar) ? data[position-i] : data[position+i]) - data[position]);
         }
         else
         {
            // TEMPO REAL: L√≥gica original
            amplitude = MathMax(amplitude, MathMax(data[position-i], data[position+i]) - data[position]);
         }
      }
   }
   
   return amplitude >= min_amplitude;
}

//+------------------------------------------------------------------+
//| Valida√ß√£o de amplitude do piv√¥ ORIGINAL - TEMPO REAL MELHORADA  |
//+------------------------------------------------------------------+
bool IsStrongPivot(const double &data[], int position, bool isHigh, int strength, double min_amplitude)
{
   if(!IsValidPivot(data, position, isHigh, strength)) return false;
   
   double amplitude = 0;
   int array_size = ArraySize(data);
   
   for(int i = 1; i <= strength; i++)
   {
      if(isHigh)
      {
         // ‚úÖ TEMPO REAL MELHORADO: Usa dados dispon√≠veis + fallback
         double left = data[position-i];
         double right = (position+i < array_size) ? data[position+i] : data[position-i]; // Fallback seguro
         amplitude = MathMax(amplitude, data[position] - MathMin(left, right));
      }
      else
      {
         // ‚úÖ TEMPO REAL MELHORADO: Usa dados dispon√≠veis + fallback
         double left = data[position-i];  
         double right = (position+i < array_size) ? data[position+i] : data[position-i]; // Fallback seguro
         amplitude = MathMax(amplitude, MathMax(left, right) - data[position]);
      }
   }
   
   return amplitude >= min_amplitude;
}

//+------------------------------------------------------------------+
//| Valida√ß√£o de diverg√™ncia real - ULTRA RELAXADA                  |
//+------------------------------------------------------------------+
bool IsRealDivergence(double price1, double price2, double rsi1, double rsi2, bool is_bullish)
{
   double price_diff_percent = MathAbs((price2 - price1) / price1) * 100.0;
   double rsi_diff = MathAbs(rsi2 - rsi1);
   
   // ULTRA RELAXADO: Filtros m√≠nimos apenas para evitar ru√≠do
   if(price_diff_percent < 0.01) return false;  // Era 0.03 - agora 0.01
   if(rsi_diff < 0.5) return false;             // Era 1.5 - agora 0.5
   
   if(is_bullish)
   {
      // Apenas verificar se h√° diverg√™ncia b√°sica
      return (price2 < price1 && rsi2 > rsi1);  // Diverg√™ncia simples
   }
   else
   {
      // Apenas verificar se h√° diverg√™ncia b√°sica
      return (price2 > price1 && rsi2 < rsi1);  // Diverg√™ncia simples
   }
}

//+------------------------------------------------------------------+
//| Valida√ß√£o de contexto de tend√™ncia MELHORADA                    |
//+------------------------------------------------------------------+
bool IsValidTrendContext(const double &price[], int pivot, int current, bool is_bullish)
{
   if(!RequireTrendContext) return true;
   
   int lookback = 15;  // Per√≠odo para an√°lise de tend√™ncia
   if(current < lookback) return true;
   
   // ‚úÖ AN√ÅLISE DE TEND√äNCIA SIMPLES: Verificar dire√ß√£o geral
   double start_price = price[current - lookback];
   double end_price = price[current];
   double trend_slope = (end_price - start_price) / lookback;
   
   // ‚úÖ CONTEXTO ADICIONAL: Verificar se est√° vindo da dire√ß√£o correta
   double mid_price = price[current - lookback/2];
   
   if(is_bullish)
   {
      // Para diverg√™ncia BULLISH: pre√ßo deve estar descendo ou est√°vel
      bool declining_trend = trend_slope <= 0.0001;
      bool came_from_high = mid_price > end_price;  // Veio de cima
      return declining_trend || came_from_high;
   }
   else
   {
      // Para diverg√™ncia BEARISH: pre√ßo deve estar subindo ou est√°vel  
      bool rising_trend = trend_slope >= -0.0001;
      bool came_from_low = mid_price < end_price;   // Veio de baixo
      return rising_trend || came_from_low;
   }
}

//+------------------------------------------------------------------+
//| Valida√ß√£o de inclina√ß√£o m√≠nima da linha de diverg√™ncia          |
//+------------------------------------------------------------------+
bool HasMinimumLineSlope(double price1, double price2, double rsi1, double rsi2, int bars_distance, bool is_bullish)
{
   if(bars_distance <= 1) return false;
   
   // ‚úÖ INCLINA√á√ÉO DO PRE√áO (por barra)
   double price_slope_per_bar = MathAbs(price2 - price1) / bars_distance;
   double price_change_percent = MathAbs((price2 - price1) / price1) * 100.0;
   
   // ‚úÖ INCLINA√á√ÉO DO RSI (por barra)  
   double rsi_slope_per_bar = MathAbs(rsi2 - rsi1) / bars_distance;
   
   // ‚úÖ CRIT√âRIOS M√çNIMOS DE INCLINA√á√ÉO
   double min_price_change = 0.05;  // M√≠nimo 0.05% de mudan√ßa no pre√ßo
   double min_rsi_change = 1.5;     // M√≠nimo 1.5 pontos RSI
   
   bool price_slope_ok = price_change_percent >= min_price_change;
   bool rsi_slope_ok = rsi_slope_per_bar >= (min_rsi_change / bars_distance);
   
   if(ShowDebugInfo && (!price_slope_ok || !rsi_slope_ok))
   {
      Print("‚ùå INCLINA√á√ÉO INSUFICIENTE: Pre√ßo=", DoubleToString(price_change_percent, 3), 
            "% (min:", min_price_change, ") | RSI/barra=", DoubleToString(rsi_slope_per_bar, 2), 
            " (min:", DoubleToString(min_rsi_change/bars_distance, 2), ")");
   }
   
   return price_slope_ok && rsi_slope_ok;
}

//+------------------------------------------------------------------+
//| Controle de sequ√™ncia RSI (evitar muitos fundos consecutivos)   |
//+------------------------------------------------------------------+
bool IsValidRSISequence(int current_bar, bool is_bullish)
{
   if(is_bullish)
   {
      // ‚úÖ CONTROLE BULLISH: Ap√≥s 3 fundos consecutivos, dar cooldown
      if(lastBullishPivotBar > 0 && (current_bar - lastBullishPivotBar) <= 8)
      {
         consecutiveBullishPivots++;
         if(consecutiveBullishPivots >= 3)
         {
            if(ShowDebugInfo)
               Print("‚ùå BULLISH REJEITADO: Muitos fundos consecutivos (", consecutiveBullishPivots, ") - cooldown");
            return false;
         }
      }
      else
      {
         consecutiveBullishPivots = 0;  // Reset contador
      }
      lastBullishPivotBar = current_bar;
   }
   else
   {
      // ‚úÖ CONTROLE BEARISH: Ap√≥s 3 topos consecutivos, dar cooldown  
      if(lastBearishPivotBar > 0 && (current_bar - lastBearishPivotBar) <= 8)
      {
         consecutiveBearishPivots++;
         if(consecutiveBearishPivots >= 3)
         {
            if(ShowDebugInfo)
               Print("‚ùå BEARISH REJEITADO: Muitos topos consecutivos (", consecutiveBearishPivots, ") - cooldown");
            return false;
         }
      }
      else
      {
         consecutiveBearishPivots = 0;  // Reset contador
      }
      lastBearishPivotBar = current_bar;
   }
   
   return true;
}

//+------------------------------------------------------------------+
//| Fun√ß√£o de filtros de signific√¢ncia - ULTRA RELAXADA             |
//+------------------------------------------------------------------+
bool CheckSignificance(double price1, double price2, double rsi1, double rsi2, 
                       bool is_bullish, ENUM_DIVERGENCE_MODE mode)
{
   double rsi_diff = MathAbs(rsi2 - rsi1);
   double price_diff_percent = MathAbs((price2 - price1) / price1) * 100.0;
   
   switch(mode)
   {
      case MODE_SENSITIVE:
         // ULTRA RELAXADO para detectar MUITAS diverg√™ncias
         return rsi_diff >= 0.1 && price_diff_percent >= 0.001; // Quase qualquer movimento
         
      case MODE_BALANCED:
         // MUITO RELAXADO tamb√©m
         return rsi_diff >= 0.5 && price_diff_percent >= 0.01;
         
      case MODE_CONSERVATIVE:
         // RELAXADO tamb√©m
         return rsi_diff >= MinRSIDifference * 0.5 && price_diff_percent >= MinPriceDifference * 0.5;
   }
   
   return false;
}

//+------------------------------------------------------------------+
//| Helper functions                                                 |
//+------------------------------------------------------------------+
double GetVolumeChangePercent(const long &tick_volume[], int start, int end) 
{ 
   if(end <= start || start < Volume_Period || end >= ArraySize(tick_volume)) return 0.0; 
   
   // ‚úÖ M√âTODO VISUAL MELHORADO: Comparar per√≠odo recente vs anterior
   int compare_period = MathMin(5, (end - start) / 2);  // Per√≠odo din√¢mico
   
   // Volume do per√≠odo recente (ao redor do end)
   long sum_recent = 0;
   for(int i = 0; i < compare_period; i++) 
   {
      if(end - i >= 0) sum_recent += tick_volume[end - i];
   }
   double avg_recent = (double)sum_recent / compare_period;
   
   // Volume do per√≠odo anterior (ao redor do start)  
   long sum_previous = 0;
   for(int i = 0; i < compare_period; i++) 
   {
      if(start - i >= 0) sum_previous += tick_volume[start - i];
   }
   double avg_previous = (double)sum_previous / compare_period;
   
   if(avg_previous <= 0) return 0.0;
   double visual_method = ((avg_recent - avg_previous) / avg_previous) * 100.0;
   
   // ‚úÖ M√âTODO ALTERNATIVO: Volume atual vs m√©dia m√≥vel longa
   long sum_long = 0; 
   for(int i = 0; i < Volume_Period; i++) 
   {
      if(end - i >= 0) sum_long += tick_volume[end - i]; 
   }
   double avg_long = (double)sum_long / Volume_Period;
   double current_vs_avg = avg_previous > 0 ? ((avg_recent - avg_long) / avg_long) * 100.0 : 0.0;
   
   // ‚úÖ USAR O M√âTODO MAIS CONSERVADOR (evita falsos positivos)
   double result = (MathAbs(visual_method) > MathAbs(current_vs_avg)) ? current_vs_avg : visual_method;
   
   if(ShowDebugInfo)
   {
      Print("üìä Volume Analysis [", start, "->", end, "]: Visual=", DoubleToString(visual_method, 1), 
            "% | vs M√©dia=", DoubleToString(current_vs_avg, 1), "% | Usado=", DoubleToString(result, 1), "%");
   }
   
   return result;
}

bool CheckVolumeConfirmation(bool is_buy, const long &tick_volume[], int start, int end) 
{ 
   double volumeChange = GetVolumeChangePercent(tick_volume, start, end); 
   
   if(ShowDebugInfo)
      Print("üìä Volume check: ", is_buy ? "BUY" : "SELL", " | Per√≠odo: ", start, "-", end, " | Mudan√ßa: ", NormalizeDouble(volumeChange, 1), "% | Limite: ", is_buy ? "+" : "-", Volume_Divergence_Min, "%");
   
   if(is_buy) 
      return volumeChange >= Volume_Divergence_Min;  
   else 
      return volumeChange <= -Volume_Divergence_Min; 
}

bool CheckMinimumVolume(const long &tick_volume[], int position) 
{ 
   if(position < Volume_Period) return true; 
   long totalVolume = 0; 
   for(int i = position - Volume_Period + 1; i <= position; i++) 
      totalVolume += tick_volume[i]; 
   double avgVolume = (double)totalVolume / Volume_Period; 
   return (double)tick_volume[position] >= (avgVolume * Min_Volume_Factor); 
}

//+------------------------------------------------------------------+
//| Sistema de scoring de qualidade - ULTRA PERMISSIVO              |
//+------------------------------------------------------------------+
double CalculateDivergenceScore(double price1, double price2, double rsi1, double rsi2, 
                               int pivot, int current, const long &volume[], bool is_bullish)
{
   double score = 20; // COME√áA COM 20 PONTOS BASE
   
   // 1. For√ßa da diverg√™ncia RSI (0-30 pontos)
   double rsi_strength = MathAbs(rsi2 - rsi1);
   score += MathMin(rsi_strength * 6, 30); // Multiplicador ainda maior
   
   // 2. For√ßa da diverg√™ncia pre√ßo (0-25 pontos)
   double price_strength = MathAbs((price2 - price1) / price1) * 100;
   score += MathMin(price_strength * 20, 25); // Multiplicador muito maior
   
   // 3. Confirma√ß√£o de volume (0-25 pontos) - SEMPRE D√Å PONTOS
   if(current > pivot && pivot >= Volume_Period && current >= Volume_Period)
   {
      double vol_change = GetVolumeChangePercent(volume, pivot, current);
      if((is_bullish && vol_change > 1) || (!is_bullish && vol_change < -1)) // Muito relaxado
         score += 25;
      else if(MathAbs(vol_change) > 0.5)
         score += 20;
      else
         score += 15; // Sempre d√° pontos
   }
   else
   {
      score += 20; // Pontos altos se n√£o pode calcular
   }
   
   // 4. Posi√ß√£o nos n√≠veis extremos (0-20 pontos) - SEMPRE D√Å PONTOS
   score += 15; // Bonus base para qualquer diverg√™ncia
   
   return score; // Score geralmente ser√° 50-100
}

//+------------------------------------------------------------------+
//| Detec√ß√£o de diverg√™ncias cl√°ssicas CORRIGIDA                    |
//+------------------------------------------------------------------+
int CheckClassicDivergence(const double &price[], const double &rsi_raw[], const long &tick_volume[], int current, bool is_bullish)
{
   if(current < DivergenceLookback) return -1;

   int pivot = -1;
   int pivot_strength = (DivergenceMode == MODE_CONSERVATIVE) ? PivotStrength + 1 : PivotStrength;
   
   // ‚úÖ CORRE√á√ÉO: Usar sempre RSI raw (0-100) para compara√ß√µes de n√≠vel
   double level = is_bullish ? (OnlyExtremeLevels ? OversoldLevel : 45.0) : (OnlyExtremeLevels ? OverboughtLevel : 55.0);
   
   if(is_bullish)
   {
      // üî• DECIDIR: Busca original (tempo real) vs melhorada (backtest)
      bool useAdvancedSearch = EnableAntiLookAhead && IsBacktest();
      
      if(useAdvancedSearch)
      {
         // BACKTEST: Buscar MELHOR piv√¥ (n√£o primeiro)
         int best_pivot = -1;
         double best_rsi = 999.0;
         
         for(int i = current - MinDistanceBetweenPivots; i >= current - DivergenceLookback; i--)
         {
            if(i < pivot_strength) break;
            
            bool priceIsBottom = IsValidPivotAntiLookAhead(price, i, false, pivot_strength, current);
            bool rsiIsBottom = IsValidPivotAntiLookAhead(rsi_raw, i, false, pivot_strength, current);
            
            if(priceIsBottom && rsiIsBottom && rsi_raw[i] < level)  // ‚úÖ Usa RSI raw para compara√ß√£o
            {
               if(IsStrongPivotAntiLookAhead(rsi_raw, i, false, pivot_strength, MinPivotAmplitude, current))
               {
                  if(rsi_raw[i] < best_rsi)
                  {
                     best_rsi = rsi_raw[i];
                     best_pivot = i;
                  }
               }
            }
         }
         pivot = best_pivot;
      }
      else
      {
         // TEMPO REAL: Busca original (primeiro piv√¥) - COMO ESTAVA FUNCIONANDO
         for(int i = current - MinDistanceBetweenPivots; i >= current - DivergenceLookback; i--)
         {
            if(i < pivot_strength) break;
            
            bool priceIsBottom = IsValidPivot(price, i, false, pivot_strength);
            bool rsiIsBottom = IsValidPivot(rsi_raw, i, false, pivot_strength);
            
            if(priceIsBottom && rsiIsBottom && rsi_raw[i] < level)
            {
               if(IsStrongPivot(rsi_raw, i, false, pivot_strength, MinPivotAmplitude))
               {
                  pivot = i;
                  break; // PARA NO PRIMEIRO (como estava)
               }
            }
         }
      }
      
      if(pivot > 0)
      {
         bool currentPriceIsBottom, currentRsiIsBottom;
         
         // üî• Verificar piv√¥ atual: Anti Look-Ahead s√≥ no backtest
         if(EnableAntiLookAhead && IsBacktest())
         {
            currentPriceIsBottom = IsValidPivotAntiLookAhead(price, current, false, pivot_strength, current + PivotConfirmationBars);
            currentRsiIsBottom = IsValidPivotAntiLookAhead(rsi_raw, current, false, pivot_strength, current + PivotConfirmationBars);
         }
         else
         {
            // TEMPO REAL: L√≥gica original (como estava funcionando)
            currentPriceIsBottom = IsValidPivot(price, current, false, pivot_strength);
            currentRsiIsBottom = IsValidPivot(rsi_raw, current, false, pivot_strength);
         }
         
         if(price[current] < price[pivot] && rsi_raw[current] > rsi_raw[pivot] && rsi_raw[current] < level)  // ‚úÖ Usa RSI raw
         {
            if(IsRealDivergence(price[pivot], price[current], rsi_raw[pivot], rsi_raw[current], true))  // ‚úÖ Usa RSI raw
            {
               // ‚úÖ NOVA VALIDA√á√ÉO: Controle de sequ√™ncia RSI
               if(!IsValidRSISequence(current, true))
                  return -1;
               
               // ‚úÖ NOVA VALIDA√á√ÉO: Inclina√ß√£o m√≠nima da linha
               if(!HasMinimumLineSlope(price[pivot], price[current], rsi_raw[pivot], rsi_raw[current], current - pivot, true))  // ‚úÖ RSI raw
               {
                  if(ShowDebugInfo)
                     Print("‚ùå BULLISH REJEITADO: Inclina√ß√£o insuficiente da linha");
                  return -1;
               }
               
               // üî• NOVA VALIDA√á√ÉO: Linha limpa (sem obstru√ß√µes)
               bool cleanLine = true;
               if(RequireCleanLine)
               {
                  cleanLine = IsCleanDivergenceLine(price, rsi_raw, pivot, current, true);  // ‚úÖ RSI raw
                  if(!cleanLine && ShowDebugInfo)
                     Print("‚ùå BULLISH REJEITADO: Linha de diverg√™ncia n√£o √© limpa (tem obstru√ß√µes)");
               }
               
               if(cleanLine && currentPriceIsBottom && currentRsiIsBottom)
               {
                  if(CheckSignificance(price[pivot], price[current], rsi_raw[pivot], rsi_raw[current], true, DivergenceMode))  // ‚úÖ RSI raw
                  {
                     if(IsValidTrendContext(price, pivot, current, true))
                     {
                        double quality_score = CalculateDivergenceScore(price[pivot], price[current], 
                                                                       rsi_raw[pivot], rsi_raw[current],   // ‚úÖ RSI raw
                                                                       pivot, current, tick_volume, true);
                        
                        double required_score = MinQualityScore;
                        if(DivergenceMode == MODE_SENSITIVE) required_score *= 0.3;
                        else if(DivergenceMode == MODE_BALANCED) required_score *= 0.5;
                        
                        if(quality_score >= required_score)
                        {
                           if(ShowDebugInfo)
                           {
                              string mode_suffix = (EnableAntiLookAhead && IsBacktest()) ? "(BACKTEST-ANTI-LA)" : "(TEMPO-REAL)";
                              Print("üü¢ DIVERG√äNCIA BULLISH [", EnumToString(DivergenceMode), "] ", mode_suffix, 
                                    " APROVADA: barra ", current, " | pivot ", pivot, " | Score: ", DoubleToString(quality_score, 1));
                           }
                           return pivot;
                        }
                        else
                        {
                           qualityFiltered++;
                           if(ShowDebugInfo)
                              Print("‚ùå BULLISH FILTRADO POR QUALIDADE [Score=", DoubleToString(quality_score, 1), "]");
                        }
                     }
                     else
                     {
                        contextFiltered++;
                     }
                  }
                  else
                  {
                     signalsFiltered++;
                  }
               }
               else if(!cleanLine)
               {
                  cleanLineFiltered++;
               }
               else
               {
                  mixedTypeFiltered++;
                  if(ShowDebugInfo)
                     Print("‚ùå BULLISH REJEITADO: MISTURA FUNDO/TOPO!");
               }
            }
            else
            {
               realDivFiltered++;
               if(ShowDebugInfo)
                  Print("‚ùå BULLISH REJEITADO: Diverg√™ncia n√£o √© real/significativa");
            }
         }
      }
   }
   else
   {
      // üî• DECIDIR: Busca original (tempo real) vs melhorada (backtest)
      bool useAdvancedSearch = EnableAntiLookAhead && IsBacktest();
      
      if(useAdvancedSearch)
      {
         // BACKTEST: Buscar MELHOR piv√¥ (n√£o primeiro)
         int best_pivot = -1;
         double best_rsi = 0.0;
         
         for(int i = current - MinDistanceBetweenPivots; i >= current - DivergenceLookback; i--)
         {
            if(i < pivot_strength) break;
            
            bool priceIsTop = IsValidPivotAntiLookAhead(price, i, true, pivot_strength, current);
            bool rsiIsTop = IsValidPivotAntiLookAhead(rsi_raw, i, true, pivot_strength, current);
            
            if(priceIsTop && rsiIsTop && rsi_raw[i] > level)  // ‚úÖ Usa RSI raw para compara√ß√£o
            {
               if(IsStrongPivotAntiLookAhead(rsi_raw, i, true, pivot_strength, MinPivotAmplitude, current))
               {
                  if(rsi_raw[i] > best_rsi)
                  {
                     best_rsi = rsi_raw[i];
                     best_pivot = i;
                  }
               }
            }
         }
         pivot = best_pivot;
      }
      else
      {
         // TEMPO REAL: Busca original (primeiro piv√¥) - COMO ESTAVA FUNCIONANDO
         for(int i = current - MinDistanceBetweenPivots; i >= current - DivergenceLookback; i--)
         {
            if(i < pivot_strength) break;
            
            bool priceIsTop = IsValidPivot(price, i, true, pivot_strength);
            bool rsiIsTop = IsValidPivot(rsi_raw, i, true, pivot_strength);
            
            if(priceIsTop && rsiIsTop && rsi_raw[i] > level)
            {
               if(IsStrongPivot(rsi_raw, i, true, pivot_strength, MinPivotAmplitude))
               {
                  pivot = i;
                  break; // PARA NO PRIMEIRO (como estava)
               }
            }
         }
      }
      
      if(pivot > 0)
      {
         bool currentPriceIsTop, currentRsiIsTop;
         
         // üî• Verificar piv√¥ atual: Anti Look-Ahead s√≥ no backtest
         if(EnableAntiLookAhead && IsBacktest())
         {
            currentPriceIsTop = IsValidPivotAntiLookAhead(price, current, true, pivot_strength, current + PivotConfirmationBars);
            currentRsiIsTop = IsValidPivotAntiLookAhead(rsi_raw, current, true, pivot_strength, current + PivotConfirmationBars);
         }
         else
         {
            // TEMPO REAL: L√≥gica original (como estava funcionando)
            currentPriceIsTop = IsValidPivot(price, current, true, pivot_strength);
            currentRsiIsTop = IsValidPivot(rsi_raw, current, true, pivot_strength);
         }
         
         if(price[current] > price[pivot] && rsi_raw[current] < rsi_raw[pivot] && rsi_raw[current] > level)  // ‚úÖ Usa RSI raw
         {
            if(IsRealDivergence(price[pivot], price[current], rsi_raw[pivot], rsi_raw[current], false))  // ‚úÖ RSI raw
            {
               // ‚úÖ NOVA VALIDA√á√ÉO: Controle de sequ√™ncia RSI
               if(!IsValidRSISequence(current, false))
                  return -1;
               
               // ‚úÖ NOVA VALIDA√á√ÉO: Inclina√ß√£o m√≠nima da linha
               if(!HasMinimumLineSlope(price[pivot], price[current], rsi_raw[pivot], rsi_raw[current], current - pivot, false))  // ‚úÖ RSI raw
               {
                  if(ShowDebugInfo)
                     Print("‚ùå BEARISH REJEITADO: Inclina√ß√£o insuficiente da linha");
                  return -1;
               }
               
               // üî• NOVA VALIDA√á√ÉO: Linha limpa (sem obstru√ß√µes)
               bool cleanLine = true;
               if(RequireCleanLine)
               {
                  cleanLine = IsCleanDivergenceLine(price, rsi_raw, pivot, current, false);  // ‚úÖ RSI raw
                  if(!cleanLine && ShowDebugInfo)
                     Print("‚ùå BEARISH REJEITADO: Linha de diverg√™ncia n√£o √© limpa (tem obstru√ß√µes)");
               }
               
               if(cleanLine && currentPriceIsTop && currentRsiIsTop)
               {
                  if(CheckSignificance(price[pivot], price[current], rsi_raw[pivot], rsi_raw[current], false, DivergenceMode))  // ‚úÖ RSI raw
                  {
                     if(IsValidTrendContext(price, pivot, current, false))
                     {
                        double quality_score = CalculateDivergenceScore(price[pivot], price[current], 
                                                                       rsi_raw[pivot], rsi_raw[current],   // ‚úÖ RSI raw
                                                                       pivot, current, tick_volume, false);
                        
                        double base_score = MinQualityScore;
                        if(DivergenceMode == MODE_SENSITIVE) base_score *= 0.3;
                        else if(DivergenceMode == MODE_BALANCED) base_score *= 0.5;
                        
                        double required_score = base_score * 0.8;
                        
                        if(quality_score >= required_score)
                        {
                           if(ShowDebugInfo)
                           {
                              string mode_suffix = (EnableAntiLookAhead && IsBacktest()) ? "(BACKTEST-ANTI-LA)" : "(TEMPO-REAL)";
                              Print("üî¥ DIVERG√äNCIA BEARISH [", EnumToString(DivergenceMode), "] ", mode_suffix, 
                                    " APROVADA: barra ", current, " | pivot ", pivot, " | Score: ", DoubleToString(quality_score, 1),
                                    RequireCleanLine ? " | LINHA LIMPA ‚úÖ" : "");
                           }
                           return pivot;
                        }
                        else
                        {
                           qualityFiltered++;
                           if(ShowDebugInfo)
                              Print("‚ùå BEARISH FILTRADO POR QUALIDADE [Score=", DoubleToString(quality_score, 1), "]");
                        }
                     }
                     else
                     {
                        contextFiltered++;
                     }
                  }
                  else
                  {
                     signalsFiltered++;
                  }
               }
               else if(!cleanLine)
               {
                  cleanLineFiltered++;
               }
               else
               {
                  mixedTypeFiltered++;
                  if(ShowDebugInfo)
                     Print("‚ùå BEARISH REJEITADO: MISTURA FUNDO/TOPO!");
               }
            }
            else
            {
               realDivFiltered++;
               if(ShowDebugInfo)
                  Print("‚ùå BEARISH REJEITADO: Diverg√™ncia n√£o √© real/significativa");
            }
         }
      }
   }
   
   return -1;
}

//+------------------------------------------------------------------+
//| Initialization function CORRIGIDA                               |
//+------------------------------------------------------------------+
int OnInit()
{
   long currentAccount = AccountInfoInteger(ACCOUNT_LOGIN);
   datetime currentTime = TimeCurrent();

   if (currentAccount != StringToInteger(licenseAccount) || currentTime > licenseExpiration) {
      Print("Licen√ßa inv√°lida ou expirada! Conta: ", currentAccount, " | Data: ", TimeToString(currentTime));
      ObjectsDeleteAll(0, "RSI_Volume_Star_");  
      ObjectsDeleteAll(0, "div_line_price_");  
      ObjectsDeleteAll(0, "VolumeDebug_");  
      ChartRedraw();
      Comment("Licen√ßa inv√°lida ou expirada!");
      Alert("Licen√ßa inv√°lida ou expirada!");
      return INIT_FAILED;
   }

   SetIndexBuffer(0, RSIBuffer, INDICATOR_DATA);
   SetIndexBuffer(1, BuyBuffer, INDICATOR_DATA);
   SetIndexBuffer(2, SellBuffer, INDICATOR_DATA);
   SetIndexBuffer(3, RSILineBuffer, INDICATOR_DATA);
   SetIndexBuffer(4, VolumeBuffer, INDICATOR_DATA);
   SetIndexBuffer(5, VolumeAvgBuffer, INDICATOR_DATA);
   SetIndexBuffer(6, VolumeBuyConfirmBuffer, INDICATOR_DATA);
   SetIndexBuffer(7, VolumeSellConfirmBuffer, INDICATOR_DATA);
   SetIndexBuffer(8, DividerBuffer, INDICATOR_DATA);
   SetIndexBuffer(9, BuySignalConfirmedBuffer, INDICATOR_DATA);
   SetIndexBuffer(10, SellSignalConfirmedBuffer, INDICATOR_DATA);
   SetIndexBuffer(11, RawRSIBuffer, INDICATOR_CALCULATIONS);
   SetIndexBuffer(12, BuyStarBacktestBuffer, INDICATOR_DATA);
   SetIndexBuffer(13, SellStarBacktestBuffer, INDICATOR_DATA);

   PlotIndexSetInteger(1, PLOT_ARROW, 233);      
   PlotIndexSetInteger(2, PLOT_ARROW, 234);      
   PlotIndexSetInteger(1, PLOT_LINE_COLOR, clrLimeGreen);  
   PlotIndexSetInteger(2, PLOT_LINE_COLOR, clrRed);        
   PlotIndexSetInteger(6, PLOT_ARROW, 159);      
   PlotIndexSetInteger(7, PLOT_ARROW, 159);
   PlotIndexSetInteger(12, PLOT_ARROW, 159);     
   PlotIndexSetInteger(13, PLOT_ARROW, 159);
   
   PlotIndexSetDouble(1, PLOT_EMPTY_VALUE, 0);
   PlotIndexSetDouble(2, PLOT_EMPTY_VALUE, 0);
   PlotIndexSetDouble(3, PLOT_EMPTY_VALUE, 0);
   PlotIndexSetDouble(6, PLOT_EMPTY_VALUE, 0);
   PlotIndexSetDouble(7, PLOT_EMPTY_VALUE, 0);
   PlotIndexSetDouble(9, PLOT_EMPTY_VALUE, 0);
   PlotIndexSetDouble(10, PLOT_EMPTY_VALUE, 0);
   PlotIndexSetDouble(12, PLOT_EMPTY_VALUE, 0);
   PlotIndexSetDouble(13, PLOT_EMPTY_VALUE, 0);

   RSIHandle = iRSI(NULL, NULL, RSI_Period, RSI_Applied);
   if(RSIHandle == INVALID_HANDLE) { return INIT_FAILED; }
   
   string mode_name = "";
   switch(DivergenceMode)
   {
      case MODE_SENSITIVE: mode_name = "SENSITIVE"; break;
      case MODE_BALANCED: mode_name = "BALANCED"; break;
      case MODE_CONSERVATIVE: mode_name = "CONSERVATIVE"; break;
   }
   
   string backtest_suffix = IsBacktest() ? "-BACKTEST" : "-TEMPO-REAL-PREMIUM";
   IndicatorSetString(INDICATOR_SHORTNAME, "Divergence RSI + Volume PrimeBot" + backtest_suffix + " [" + mode_name + "]");
   
   IndicatorSetInteger(INDICATOR_LEVELS, 6);  // 6 n√≠veis
   
   // ‚úÖ N√çVEIS CORRIGIDOS - Valores originais RSI para escala √† direita correta
   
   // Linha divis√≥ria principal RSI/Volume - PRATICAMENTE INVIS√çVEL
   IndicatorSetDouble(INDICATOR_LEVELVALUE, 0, DIVIDER_LINE);
   IndicatorSetInteger(INDICATOR_LEVELCOLOR, 0, clrNONE);           // ‚úÖ SEM COR = invis√≠vel
   IndicatorSetInteger(INDICATOR_LEVELSTYLE, 0, STYLE_DOT);         // ‚úÖ Pontilhado m√≠nimo
   IndicatorSetInteger(INDICATOR_LEVELWIDTH, 0, 1);                // ‚úÖ Fino
   
   // RSI 70 (Overbought) - valor original
   IndicatorSetDouble(INDICATOR_LEVELVALUE, 1, 70.0);
   IndicatorSetInteger(INDICATOR_LEVELCOLOR, 1, clrRed);
   IndicatorSetInteger(INDICATOR_LEVELSTYLE, 1, STYLE_DASH);
   IndicatorSetInteger(INDICATOR_LEVELWIDTH, 1, 1);
   
   // RSI 50 (Meio) - valor original
   IndicatorSetDouble(INDICATOR_LEVELVALUE, 2, 50.0);
   IndicatorSetInteger(INDICATOR_LEVELCOLOR, 2, clrGray);
   IndicatorSetInteger(INDICATOR_LEVELSTYLE, 2, STYLE_DOT);
   IndicatorSetInteger(INDICATOR_LEVELWIDTH, 2, 1);
   
   // RSI 30 (Oversold) - valor original
   IndicatorSetDouble(INDICATOR_LEVELVALUE, 3, 30.0);
   IndicatorSetInteger(INDICATOR_LEVELCOLOR, 3, clrRed);
   IndicatorSetInteger(INDICATOR_LEVELSTYLE, 3, STYLE_DASH);
   IndicatorSetInteger(INDICATOR_LEVELWIDTH, 3, 1);
   
   // Volume m√°ximo (refer√™ncia) - MAIS SUTIL
   IndicatorSetDouble(INDICATOR_LEVELVALUE, 4, VOLUME_ZONE_MAX);
   IndicatorSetInteger(INDICATOR_LEVELCOLOR, 4, clrDimGray);        // ‚úÖ Cor mais suave
   IndicatorSetInteger(INDICATOR_LEVELSTYLE, 4, STYLE_DASHDOTDOT);  // ‚úÖ Estilo mais discreto
   IndicatorSetInteger(INDICATOR_LEVELWIDTH, 4, 1);
   
   // Volume meio (refer√™ncia) - MAIS SUTIL
   IndicatorSetDouble(INDICATOR_LEVELVALUE, 5, VOLUME_ZONE_MAX/2);
   IndicatorSetInteger(INDICATOR_LEVELCOLOR, 5, clrDimGray);        // ‚úÖ Cor mais suave
   IndicatorSetInteger(INDICATOR_LEVELSTYLE, 5, STYLE_DASHDOTDOT);  // ‚úÖ Estilo mais discreto
   IndicatorSetInteger(INDICATOR_LEVELWIDTH, 5, 1);
   
   IndicatorSetString(INDICATOR_LEVELTEXT, 0, "");
   IndicatorSetString(INDICATOR_LEVELTEXT, 1, "RSI 70 (Overbought)");
   IndicatorSetString(INDICATOR_LEVELTEXT, 2, "RSI 50 (Neutro)");
   IndicatorSetString(INDICATOR_LEVELTEXT, 3, "RSI 30 (Oversold)");
   IndicatorSetString(INDICATOR_LEVELTEXT, 4, "Vol Max");
   IndicatorSetString(INDICATOR_LEVELTEXT, 5, "Vol M√©dio");
   
   // üî• NOVO v2.1.5-FIX: Inicializar contador de falhas
   copyBufferFailures = 0;
   
   if(ShowDebugInfo || ShowModeInfo)
   {
      Print("üî• RSI VOLUME FUSION v2.1.5-FIX - TEMPO REAL CORRIGIDO!");
      Print("üéØ MODO ATIVO: ", mode_name, " (ULTRA RESPONSIVO + QUALIDADE)");
      Print("üîß CORRE√á√ïES v2.1.5-FIX IMPLEMENTADAS:");
      Print("   ‚úÖ COPYBUFFER CORRIGIDO: N√£o trava mais ao falhar!");
      Print("   ‚úÖ PIV√î TEMPO REAL: Detec√ß√£o melhorada na barra atual");
      Print("   ‚úÖ ESCALA √Ä DIREITA: N√∫meros corretos (0-100 original)");
      Print("   ‚úÖ SEPARA√á√ÉO VISUAL: RSI zona superior + Volume zona inferior");
      Print("   ‚úÖ LINHA DIVIS√ìRIA: Invis√≠vel (sem interfer√™ncia visual)");
      Print("   ‚úÖ N√çVEIS RSI: 30, 50, 70 (valores originais RSI)");
      Print("   ‚úÖ CONTROLE SEQU√äNCIA: Evita sinais ap√≥s fundos consecutivos");
      Print("   ‚úÖ INCLINA√á√ÉO M√çNIMA: Filtra linhas quase retas");
      Print("   ‚úÖ CONTEXTO TEND√äNCIA: Diverg√™ncia no contexto correto");
      Print("   ‚úÖ VOLUME VISUAL: M√©todo comparativo melhorado");
      Print("   ‚úÖ DEBUG VISUAL: % volume mostrado no gr√°fico");
      Print("   üöÄ TEMPO REAL: M√°xima responsividade (sem delays)");
      Print("   üöÄ ANTI LOOK-AHEAD: DESATIVADO (comportamento consistente)");
      Print("   üöÄ Confirma√ß√£o de Piv√¥: IMEDIATA (sem barras de espera)");
      Print("   üî• CORRE√á√ÉO PRINCIPAL: CopyBuffer n√£o trava mais indicador!");
      Print("   ‚úÖ MinBarsBetweenSignals = ", MinBarsBetweenSignals, " (responsivo)");
      Print("   ‚úÖ DivergenceLookback = ", DivergenceLookback, " (otimizado)");
      Print("   ‚úÖ Volume_Divergence_Min = ", Volume_Divergence_Min, "% (relaxado)");
      Print("   ‚úÖ Volume_Period = ", Volume_Period, " barras (otimizado)");
      Print("   ‚úÖ PivotStrength = ", PivotStrength, " (m√°xima sensibilidade)");
      Print("   ‚úÖ MinQualityScore = ", MinQualityScore, " (balanceado)");
      Print("   ‚úÖ RequireCleanLine = ", RequireCleanLine ? "SIM" : "N√ÉO", " (configur√°vel)");
      Print("üéØ RESULTADO: Sinais de qualidade aparecem INSTANTANEAMENTE!");
      Print("üîß NOVIDADE: Sinais atualizando ao vivo, sem precisar refresh!");
   }
   
   return INIT_SUCCEEDED;
}

//+------------------------------------------------------------------+
//| Deinitialization function                                        |
//+------------------------------------------------------------------+
void OnDeinit(const int reason) 
{ 
   if(RSIHandle != INVALID_HANDLE) IndicatorRelease(RSIHandle); 
   ObjectsDeleteAll(0, "RSI_Volume_Star_"); 
   ObjectsDeleteAll(0, "div_line_price_"); 
   ObjectsDeleteAll(0, "VolumeDebug_");     // Limpar debug de volume
   
   if(ShowDebugInfo)
   {
      Print("üî• ESTAT√çSTICAS FINAIS v2.1.5-FIX [", IsBacktest() ? "BACKTEST" : "TEMPO-REAL-PREMIUM", "]:");
      Print("   üéØ Modo usado: ", EnumToString(DivergenceMode), " (Premium Quality)");
      Print("   üöÄ Configura√ß√£o: PREMIUM - Responsividade + Qualidade");
      Print("   üöÄ Melhorias aplicadas: Separa√ß√£o visual + Filtros inteligentes + Escalas corretas");
      Print("   üöÄ Anti Look-Ahead: DESATIVADO (comportamento consistente)");
      Print("   üöÄ Delays: ELIMINADOS (sinais instant√¢neos)");
      Print("   üî• CopyBuffer: CORRIGIDO (n√£o trava mais)");
      Print("   üî• Falhas CopyBuffer detectadas: ", copyBufferFailures);
      Print("   üîç Diverg√™ncias detectadas: ", divergencesDetected);
      Print("   üìà Linhas tra√ßadas: ", divergencesDetected, " (TODAS vis√≠veis)");
      Print("   ‚≠ê Estrelas confirmadas: ", signalsConfirmed, " (volume sempre verificado)");
      Print("   üìä Taxa de aprova√ß√£o: ", signalsConfirmed > 0 ? DoubleToString((double)signalsConfirmed/(divergencesDetected > 0 ? divergencesDetected : 1)*100, 1) : "0", "%");
      Print("   üéØ SEQU√äNCIA: Bullish pivots consecutivos controlados: ", consecutiveBullishPivots);
      Print("   üéØ SEQU√äNCIA: Bearish pivots consecutivos controlados: ", consecutiveBearishPivots);
      Print("üéØ RESULTADO PREMIUM: Qualidade superior + Visual elegante + Zero repintura + SINAIS AO VIVO!");
   }
}

//+------------------------------------------------------------------+
//| Helper functions para objetos                                   |
//+------------------------------------------------------------------+
void CreateStar(datetime time, double price, bool isBuy) 
{ 
   starCounter++; 
   string starName = "RSI_Volume_Star_" + (string)starCounter + (string)TimeCurrent(); 
   if(ObjectCreate(0, starName, OBJ_ARROW_CHECK, 0, time, price))
   {
      ObjectSetInteger(0, starName, OBJPROP_ARROWCODE, SYMBOL_STAR);
      ObjectSetInteger(0, starName, OBJPROP_WIDTH, 4);
      ObjectSetInteger(0, starName, OBJPROP_SELECTABLE, false);
      if(isBuy) 
         ObjectSetInteger(0, starName, OBJPROP_COLOR, clrGold);
      else 
         ObjectSetInteger(0, starName, OBJPROP_COLOR, clrMagenta);
   }
   ChartRedraw(); 
}

void FillBufferLine(double &buffer[], int p1, int p2, const double &prices[]) 
{ 
   if(p1 >= ArraySize(buffer) || p2 >= ArraySize(buffer) || p1 < 0 || p2 < 0 || p1 == p2) 
      return; 
   double start_price = prices[p1]; 
   double end_price = prices[p2]; 
   for(int j = p1; j <= p2; j++) 
   { 
      if(p2 - p1 == 0) continue; 
      double ratio = (double)(j - p1) / (double)(p2 - p1); 
      buffer[j] = start_price + ratio * (end_price - start_price); 
   } 
}

//+------------------------------------------------------------------+
//| Fun√ß√£o para mostrar texto no gr√°fico com informa√ß√µes de volume  |
//+------------------------------------------------------------------+
void CreateVolumeDebugText(datetime time, double price, string text, color textColor)
{
   string objName = "VolumeDebug_" + (string)time + "_" + (string)MathRand();
   
   if(ObjectCreate(0, objName, OBJ_TEXT, 0, time, price))
   {
      ObjectSetInteger(0, objName, OBJPROP_COLOR, textColor);
      ObjectSetInteger(0, objName, OBJPROP_FONTSIZE, 7);  // ‚úÖ Fonte menor, mais discreta
      ObjectSetString(0, objName, OBJPROP_TEXT, text);
      ObjectSetInteger(0, objName, OBJPROP_ANCHOR, ANCHOR_LEFT_UPPER);
   }
}

void CreatePriceLine(datetime time1, double price1, datetime time2, double price2, bool is_bullish) 
{ 
   lineCounter++; 
   string line_name = "div_line_price_" + (string)lineCounter + (string)TimeCurrent(); 
   if(ObjectCreate(0, line_name, OBJ_TREND, 0, time1, price1, time2, price2)) 
   { 
      ObjectSetInteger(0, line_name, OBJPROP_COLOR, is_bullish ? clrLimeGreen : clrRed); 
      ObjectSetInteger(0, line_name, OBJPROP_STYLE, STYLE_SOLID); 
      ObjectSetInteger(0, line_name, OBJPROP_WIDTH, 2); 
      ObjectSetInteger(0, line_name, OBJPROP_RAY_RIGHT, false); 
   } 
}

//+------------------------------------------------------------------+
//| Main calculation function CORRIGIDA v2.1.5-FIX                 |
//+------------------------------------------------------------------+
int OnCalculate(const int rates_total, const int prev_calculated, const datetime &time[], 
                const double &open[], const double &high[], const double &low[], 
                const double &close[], const long &tick_volume[], const long &volume[], 
                const int &spread[])
{
   if(rates_total < RSI_Period + 10) return 0;
   
   // üî• CORRE√á√ÉO PRINCIPAL v2.1.5-FIX: CopyBuffer com tratamento correto de falhas
   int rsi_copied = CopyBuffer(RSIHandle, 0, 0, rates_total, RawRSIBuffer);
   if(rsi_copied <= 0) 
   { 
      copyBufferFailures++; // Contar falhas para estat√≠sticas
      
      if(ShowDebugInfo)
         Print("‚ö†Ô∏è CopyBuffer falhou (normal): Tentativa ", copyBufferFailures, " | Erro: ", GetLastError(), " | Retentando...");
      
      // üî• CORRE√á√ÉO CR√çTICA: Retornar 0 for√ßa o MT5 a tentar recalcular
      // Antes: return prev_calculated; (causava travamento)
      // Agora: return 0; (for√ßa nova tentativa)
      return 0; // ‚úÖ CORRIGIDO: N√£o trava mais!
   }
   
   if(prev_calculated == 0) 
   {
      g_max_volume = 1;
      divergencesDetected = 0;
      signalsConfirmed = 0;
      signalsFiltered = 0;
      qualityFiltered = 0;
      contextFiltered = 0;
      mixedTypeFiltered = 0;
      realDivFiltered = 0;
      cleanLineFiltered = 0;
      
      // ‚úÖ RESETAR CONTADORES DE SEQU√äNCIA
      lastBullishPivotBar = -1;
      lastBearishPivotBar = -1;
      consecutiveBullishPivots = 0;
      consecutiveBearishPivots = 0;
      
      if(ShowDebugInfo)
         Print("üîÑ Iniciando FUSION v2.1.5-FIX [", IsBacktest() ? "BACKTEST" : "TEMPO-REAL", "] [", EnumToString(DivergenceMode), "] | Anti-LA:", (EnableAntiLookAhead && IsBacktest()) ? "ON" : "OFF", " | Total barras: ", rates_total);
   }
   
   int start_calc = prev_calculated > 1 ? prev_calculated - 1 : 0;
   
   // ‚úÖ CORRE√á√ÉO: Atualizar buffers mantendo escala 0-100 para n√∫meros corretos
   for(int i = start_calc; i < rates_total; i++)
   {
      if(tick_volume[i] > g_max_volume) g_max_volume = tick_volume[i];
      
      // ‚úÖ RSI: Manter valores originais 0-100, mas posicionar na zona correta visualmente
      if(RawRSIBuffer[i] <= 30.0)
      {
         // Valores baixos (0-30) ficam comprimidos pr√≥ximo a 30
         RSIBuffer[i] = 30.0 + (RawRSIBuffer[i] / 30.0) * 5.0; // Comprime em 5 pontos
      }
      else
      {
         // Valores 30-100 mant√™m propor√ß√£o original na zona 35-100
         RSIBuffer[i] = 35.0 + ((RawRSIBuffer[i] - 30.0) / 70.0) * 65.0;
      }
      
      DividerBuffer[i] = DIVIDER_LINE;  // Linha divis√≥ria suave
      VolumeBuffer[i] = ScaleVolumeValue(tick_volume[i], g_max_volume);  // Volume na zona 0-25
      
      if(i >= Volume_Period) 
      { 
         long sum_vol = 0; 
         for(int j=0; j<Volume_Period; j++) 
            sum_vol += tick_volume[i-j]; 
         VolumeAvgBuffer[i] = ScaleVolumeValue(sum_vol/Volume_Period, g_max_volume); 
      }
   }
   
   int limit = prev_calculated == 0 ? RSI_Period + DivergenceLookback : prev_calculated - 1;
   
   // ‚úÖ CORRE√á√ÉO TEMPO REAL v2.1.5-FIX: Processar at√© barra atual sempre
   int max_process = rates_total; // ‚úÖ TEMPO REAL: Sempre processa at√© a barra atual
   
   if(ShowDebugInfo)
   {
      if(prev_calculated == 0)
         Print("üîÑ PRIMEIRA EXECU√á√ÉO v2.1.5-FIX [", IsBacktest() ? "BACKTEST" : "TEMPO-REAL-CORRIGIDO", "] [", EnumToString(DivergenceMode), "]: Processando de ", limit, " at√© ", max_process);
      else if(copyBufferFailures == 0) // S√≥ mostra se n√£o houve falhas
         Print("üîÑ ATUALIZA√á√ÉO TEMPO REAL v2.1.5-FIX: Processando de ", limit, " at√© ", max_process, " (INSTANT√ÇNEO + SEM TRAVAMENTOS)");
   }
   
   // üî• LOOP PRINCIPAL DE PROCESSAMENTO - CORRIGIDO
   for(int i = limit; i < max_process; i++)
   {
      // Limpar buffers
      BuyBuffer[i] = 0; 
      SellBuffer[i] = 0;
      RSILineBuffer[i] = 0;
      VolumeBuyConfirmBuffer[i] = 0; 
      VolumeSellConfirmBuffer[i] = 0;
      BuySignalConfirmedBuffer[i] = 0; 
      SellSignalConfirmedBuffer[i] = 0;
      BuyStarBacktestBuffer[i] = 0; 
      SellStarBacktestBuffer[i] = 0;
      
      if(i < RSI_Period || RawRSIBuffer[i] == 0) continue;
      
      // ===== DETEC√á√ÉO DE COMPRA =====
      int buy_pivot = CheckClassicDivergence(low, RawRSIBuffer, tick_volume, i, true);  // ‚úÖ Usa RawRSIBuffer
      if(buy_pivot > 0)
      {
         divergencesDetected++;
         BuyBuffer[i] = RSIBuffer[i] - 3.0;  // Sinal de compra abaixo do RSI (mais pr√≥ximo)
         
         // üî• SEMPRE DESENHAR LINHAS DE DIVERG√äNCIA üî•
         FillBufferLine(RSILineBuffer, buy_pivot, i, RSIBuffer);  // ‚úÖ Usa RSI escalonado para desenho
         if(ShowDivergenceLines)
            CreatePriceLine(time[buy_pivot], low[buy_pivot], time[i], low[i], true);
         
         if(ShowDebugInfo)
            Print("üü¢ DIVERG√äNCIA BULLISH DETECTADA v2.1.5-FIX [", EnumToString(DivergenceMode), "] na barra ", i, " | LINHA TRA√áADA");
         
         // ===== SEMPRE VERIFICAR VOLUME PARA ESTRELA =====
         bool showStar = false;
         double volumeChangePercent = GetVolumeChangePercent(tick_volume, buy_pivot, i);
         bool volConfirmed = CheckVolumeConfirmation(true, tick_volume, buy_pivot, i);
         bool minVolOk = CheckMinimumVolume(tick_volume, i);
         
         // üîß DEBUG VISUAL NO GR√ÅFICO
         if(ShowVolumeDebugOnChart)
         {
            string debugText = "Vol:" + DoubleToString(volumeChangePercent, 1) + "%";
            color debugColor = volConfirmed ? clrLimeGreen : clrRed;
            CreateVolumeDebugText(time[i], low[i] - SymbolInfoDouble(_Symbol, SYMBOL_POINT) * 30, debugText, debugColor);
         }
         
         if(volConfirmed && minVolOk)
         {
            showStar = true;
            if(ShowDebugInfo)
               Print("‚≠ê COMPRA - Volume confirmado: SIM (", NormalizeDouble(volumeChangePercent, 1), "%)");
         }
         else
         {
            if(ShowDebugInfo)
               Print("‚ùå COMPRA - Volume N√ÉO confirmado (Vol:", volConfirmed, " | Min:", minVolOk, " | Mudan√ßa:", NormalizeDouble(volumeChangePercent, 1), "% | Necess√°rio:+", Volume_Divergence_Min, "%)");
         }
         
         // ===== MOSTRAR ESTRELA SE CONFIRMADO =====
         if(showStar && (i - lastBuySignalBar > MinBarsBetweenSignals))
         {
            lastBuySignalBar = i;
            signalsConfirmed++;
            
            if(EnableSignalsForEA) BuySignalConfirmedBuffer[i] = 1.0;
            BuyStarBacktestBuffer[i] = high[i];
            
            // Mostrar confirma√ß√£o de volume no buffer
            double confirmLevel = MathMin(VolumeAvgBuffer[i] + 3, VOLUME_ZONE_MAX - 1);
            VolumeBuyConfirmBuffer[i] = confirmLevel;
            
            if(ShowStarsOnChart) 
               CreateStar(time[i], low[i] - SymbolInfoDouble(_Symbol, SYMBOL_POINT) * 15, true);
            
            if(ShowDebugInfo)
               Print("‚≠ê ESTRELA COMPRA CONFIRMADA v2.1.5-FIX [", EnumToString(DivergenceMode), "] na barra ", i);
         }
      }
      
      // ===== DETEC√á√ÉO DE VENDA =====
      int sell_pivot = CheckClassicDivergence(high, RawRSIBuffer, tick_volume, i, false);  // ‚úÖ Usa RawRSIBuffer
      if(sell_pivot > 0)
      {
         divergencesDetected++;
         SellBuffer[i] = RSIBuffer[i] + 3.0;  // Sinal de venda acima do RSI (mais pr√≥ximo)
         
         // üî• SEMPRE DESENHAR LINHAS DE DIVERG√äNCIA üî•
         FillBufferLine(RSILineBuffer, sell_pivot, i, RSIBuffer);  // ‚úÖ Usa RSI escalonado para desenho
         if(ShowDivergenceLines)
            CreatePriceLine(time[sell_pivot], high[sell_pivot], time[i], high[i], false);
         
         if(ShowDebugInfo)
            Print("üî¥ DIVERG√äNCIA BEARISH DETECTADA v2.1.5-FIX [", EnumToString(DivergenceMode), "] na barra ", i, " | LINHA TRA√áADA");
         
         // ===== SEMPRE VERIFICAR VOLUME PARA ESTRELA =====
         bool showStar = false;
         double volumeChangePercent = GetVolumeChangePercent(tick_volume, sell_pivot, i);
         bool volConfirmed = CheckVolumeConfirmation(false, tick_volume, sell_pivot, i);
         bool minVolOk = CheckMinimumVolume(tick_volume, i);
         
         // üîß DEBUG VISUAL NO GR√ÅFICO
         if(ShowVolumeDebugOnChart)
         {
            string debugText = "Vol:" + DoubleToString(volumeChangePercent, 1) + "%";
            color debugColor = volConfirmed ? clrMagenta : clrRed;
            CreateVolumeDebugText(time[i], high[i] + SymbolInfoDouble(_Symbol, SYMBOL_POINT) * 30, debugText, debugColor);
         }
         
         if(volConfirmed && minVolOk)
         {
            showStar = true;
            if(ShowDebugInfo)
               Print("‚≠ê VENDA - Volume confirmado: SIM (", NormalizeDouble(volumeChangePercent, 1), "%)");
         }
         else
         {
            if(ShowDebugInfo)
               Print("‚ùå VENDA - Volume N√ÉO confirmado (Vol:", volConfirmed, " | Min:", minVolOk, " | Mudan√ßa:", NormalizeDouble(volumeChangePercent, 1), "% | Necess√°rio:-", Volume_Divergence_Min, "%)");
         }
         
         // ===== MOSTRAR ESTRELA SE CONFIRMADO =====
         if(showStar && (i - lastSellSignalBar > MinBarsBetweenSignals))
         {
            lastSellSignalBar = i;
            signalsConfirmed++;
            
            if(EnableSignalsForEA) SellSignalConfirmedBuffer[i] = 1.0;
            SellStarBacktestBuffer[i] = low[i];
            
            // Mostrar confirma√ß√£o de volume no buffer
            double confirmLevel = MathMin(VolumeAvgBuffer[i] + 3, VOLUME_ZONE_MAX - 1);
            VolumeSellConfirmBuffer[i] = confirmLevel;
            
            if(ShowStarsOnChart) 
               CreateStar(time[i], high[i] + SymbolInfoDouble(_Symbol, SYMBOL_POINT) * 15, false);
            
            if(ShowDebugInfo)
               Print("‚≠ê ESTRELA VENDA CONFIRMADA v2.1.5-FIX [", EnumToString(DivergenceMode), "] na barra ", i);
         }
      }
   }
   
   if(ShowDebugInfo && prev_calculated == 0)
   {
      Print("üîÑ HIST√ìRICO PROCESSADO v2.1.5-FIX [", IsBacktest() ? "BACKTEST" : "TEMPO-REAL-CORRIGIDO", "]!");
      Print("   üìä Total barras processadas: ", rates_total);
      Print("   üîç Diverg√™ncias detectadas: ", divergencesDetected);
      Print("   üìà Linhas tra√ßadas: ", divergencesDetected, " (TODAS as diverg√™ncias RSI)");
      Print("   ‚≠ê Estrelas confirmadas: ", signalsConfirmed, " (volume sempre verificado)");
      Print("   üî• Falhas CopyBuffer: ", copyBufferFailures, " (tratadas corretamente)");
      Print("   üöÄ CORRE√á√ïES APLICADAS:");
      Print("      ‚úÖ CopyBuffer CORRIGIDO: N√£o trava mais quando falha!");
      Print("      ‚úÖ Piv√¥ Tempo Real: Detec√ß√£o na barra atual melhorada");
      Print("      ‚úÖ Escala √† direita corrigida (0-100 original)");
      Print("      ‚úÖ Separa√ß√£o visual: RSI zona superior, Volume zona inferior");
      Print("      ‚úÖ N√≠veis RSI corretos: 30, 50, 70 (valores originais)");
      Print("      ‚úÖ Linha divis√≥ria ultra discreta");
      Print("      ‚úÖ Controle de sequ√™ncia (evita fundos consecutivos)");
      Print("      ‚úÖ Valida√ß√£o de inclina√ß√£o m√≠nima");
      Print("      ‚úÖ Contexto de tend√™ncia melhorado");
      Print("      ‚úÖ Volume visual aprimorado");
      Print("   üöÄ RESPONSIVIDADE M√ÅXIMA: Detecta at√© barra atual!");
      Print("   üöÄ SEM REPINTURA: Comportamento consistente sempre!");
      Print("   üöÄ SEM TRAVAMENTOS: CopyBuffer tratado corretamente!");
      Print("   üéØ QUALIDADE: Evita Print 1, detecta Print 3, sinais ao vivo!");
   }
   
   return rates_total; // ‚úÖ SEMPRE retorna rates_total quando bem-sucedido
}
//+------------------------------------------------------------------+
